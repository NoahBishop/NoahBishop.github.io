<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
		<title itemprop="name">
			
				(ch11) Object-Oriented Programming | 
						うさぎの手帳
		</title>
		
			<link rel="shortcut icon" href="/images/favicon.ico">
			
				<meta http-equiv="x-dns-prefetch-control" content="on">
				<link rel="stylesheet"
					href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC"
					media="all">
				<link rel="dns-prefetch" href="//cdn.jsdelivr.net">
				<link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
				<link rel="stylesheet" href="/css/lib.min.css" media="all">
				<link rel="stylesheet" href="/css/font.css" media="all">
				<link rel="stylesheet" href="/css/insight.css" media="all">
				<link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
				<link rel="stylesheet" href="/css/zoom.css" media="all">
				<link rel="stylesheet" type="text/css" href="/css/sharejs.css">
				<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
				<script>
					/*Initial Variables*/
					var mashiro_option = new Object();
					var mashiro_global = new Object();
					mashiro_option.NProgressON = true;
					/* 
					* 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
					* 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
					*/
					mashiro_option.email_domain = "";
					mashiro_option.email_name = "";
					mashiro_option.cookie_version_control = "";
					mashiro_option.qzone_autocomplete = false;
					mashiro_option.site_name = "桜荘そのうさぎ";
					mashiro_option.author_name = "うさぎ";
					mashiro_option.site_url = "https://morning.eu.org";
					mashiro_option.v_appId = "EAyicHJhXmxJNEeuhACVujd4-gzGzoHsz";
					mashiro_option.v_appKey = "09Tjj4It5DOhgboduuM40u7y";
					mashiro_option.mathjax = "0";
	//mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/";
	//mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

	// mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
	// mashiro_option.float_player_on = true;

					/*End of Initial Variables*/
				</script>
				<script type="text/javascript">
					var bg = "https://morning.eu.org/images/cover/(1).jpg.webp,https://morning.eu.org/images/cover/(2).jpg.webp,https://morning.eu.org/images/cover/(3).jpg.webp,https://morning.eu.org/images/cover/(4).jpg.webp,https://morning.eu.org/images/cover/(5).jpg.webp,https://morning.eu.org/images/cover/(6).jpg.webp,https://morning.eu.org/images/cover/(7).jpg.webp,https://morning.eu.org/images/cover/(8).jpg.webp".split(",");
					var bgindex = Math.floor(Math.random() * bg.length);
					if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
						alert('朋友，IE浏览器未适配哦~');
					}
				</script>
				<script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script>
				<script src='//unpkg.com/valine@1.3.9/dist/Valine.min.js'></script>
				<style type="text/css">
					.hljs-ln {
						border-collapse: collapse
					}

					.hljs-ln td {
						padding: 0
					}

					.hljs-ln-n:before {
						content: attr(data-line-number)
					}
				</style>
				<style type="text/css">
					.site-top .lower nav {
						display: block !important;
					}

					.author-profile i,
					.post-like a,
					.post-share .show-share,
					.sub-text,
					.we-info a,
					span.sitename,
					.post-more i:hover,
					#pagination a:hover,
					.post-content a:hover,
					.float-content i:hover {
						color: #FE9600
					}

					.feature i,
					.download,
					.navigator i:hover,
					.links ul li:before,
					.ar-time i,
					span.ar-circle,
					.object,
					.comment .comment-reply-link,
					.siren-checkbox-radio:checked+.siren-checkbox-radioInput:after {
						background: #FE9600
					}

					::-webkit-scrollbar-thumb {
						background: #FE9600
					}

					.download,
					.navigator i:hover,
					.link-title,
					.links ul li:hover,
					#pagination a:hover,
					.comment-respond input[type='submit']:hover {
						border-color: #FE9600
					}

					.entry-content a:hover,
					.site-info a:hover,
					.comment h4 a,
					#comments-navi a.prev,
					#comments-navi a.next,
					.comment h4 a:hover,
					.site-top ul li a:hover,
					.entry-title a:hover,
					#archives-temp h3,
					span.page-numbers.current,
					.sorry li a:hover,
					.site-title a:hover,
					i.iconfont.js-toggle-search.iconsearch:hover,
					.comment-respond input[type='submit']:hover {
						color: #FE9600
					}

					.comments .comments-main {
						display: block !important;
					}

					.comments .comments-hidden {
						display: none !important;
					}

					background-position:center center;
					background-attachment:inherit;
					}
				</style>
<meta name="generator" content="Hexo 5.4.2"></head>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a target="_blank" rel="noopener" href="https://morning.eu.org">
          <img src="https://morning.eu.org/images/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>
          Live your life with passion! With some drive!
        </p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="/images/other/next-b.svg">
          </li>
          
            
              
                  <li>
                    <a href="https://github.com/NoahBishop" target="_blank" class="social-github" title="github">
                      <img src="https://morning.eu.org/images/social/github.png">
                    </a>
                  </li>
                  
                    
              
                  <li>
                    <a href="https://t.me/mega1037" target="_blank" class="social-github" title="telegram">
                      <img src="https://morning.eu.org/images/social/telegram.png">
                    </a>
                  </li>
                  
                    
              
                  <li>
                    <a href="https://music.163.com/#/user/home?id=305378376" target="_blank" class="social-github" title="netease">
                      <img src="https://morning.eu.org/images/social/wangyiyun.png">
                    </a>
                  </li>
                  
                    
              
                  <li>
                    <a href="https://www.twitter.com/noah_bishop_z" target="_blank" class="social-github" title="twitter">
                      <img src="https://morning.eu.org/images/social/twitter.png">
                    </a>
                  </li>
                  
                    
              
                  <li>
                    <a href="mailto:beiloquuw@gamil.com" target="_blank" class="social-github" title="email">
                      <img src="https://morning.eu.org/images/social/email.svg">
                    </a>
                  </li>
                  
                    
                      
                        <li id="bg-next">
                          <img src="/images/other/next-b.svg">
                        </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">桜荘その</span>
            <span class="shironeko">うさぎ</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E7%94%9F%E6%B4%BB/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%B5%84%E6%BA%90/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E9%9A%8F%E6%83%B3/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/tags/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-tag" aria-hidden="true"></i>
                    标签
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url('/images/cover/(3).jpg.webp');" src="" data-src="/images/cover/(3).jpg.webp">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      (ch11) Object-Oriented Programming</h1>
      <p class="entry-census">
        <span>
          <a href="morning.eu.org">
            <img src="/images/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="morning.eu.org">Noah</a>
        </span>
        <span class="bull">
        ·</span>
        2021-12-11<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h1><p>Object-oriented programming is based on three fundamental concepts: data abstraction, which we covered in Chapter 3, and inheritance and dynamic binding, which we’ll cover in this chapter.</p>
<h2 id="OOP-An-Overview"><a href="#OOP-An-Overview" class="headerlink" title="OOP: An Overview"></a>OOP: An Overview</h2><p>The key ideas in object-oriented programming are data abstraction, inheritance, and dynamic binding. Using data abstraction, we can define classes that separate interface from implementation (Chapter 3). Through inheritance, we can define classes that model the relationships among similar types. Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>Classes related by inheritance form a hierarchy. Typically there is a base class at the root of the hierarchy, from which the other classes inherit, directly or indirectly. These inheriting classes are known as derived classes. The base class defines those members that are common to the types in the hierarchy. Each derived class defines those members that are specific to the derived class itself.</p>
<p>To model different kinds of pricing strategies, we’ll define a class named Quote, which will be the base class of our hierarchy. A Quote object will represent undiscounted books. From Quote we will inherit a second class, named Bulk_quote, to represent books that can be sold with a quantity discount.</p>
<p>These classes will have the following two member functions:</p>
<ol>
<li><code>isbn()</code>, which will return the ISBN. This operation does not depend on the specifics of the inherited class(es); it will be defined only in class <code>Quote</code>.</li>
<li><code>net_price(size_t)</code>, which will return the price for purchasing a specified number of copies of a book. This operation is type specific; both Quote and Bulk_quote will define their own version of this function.</li>
</ol>
<p>In C++, a base class distinguishes functions that are type dependent from those that it expects its derived classes to inherit without change. The base class defines as <code>virtual</code> those functions it expects its derived classes to define for themselves. Using this knowledge, we can start to write our Quote class:</p>
<pre><code class="c++">class Quote &#123;
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
&#125;;

class Bulk_quote : public Quote &#123; // Bulk_quote inherits from Quote
public:
    double net_price(std::size_t) const override;
&#125;;
</code></pre>
<p>A derived class must specify the class(es) from which it intends to inherit. It does so in a class derivation list, which is a colon followed by a comma-separated list of base classes each of which may have an optional access specifier.</p>
<p>Because Bulk_quote uses <code>public</code> in its derivation list, we can use objects of type Bulk_quote as if they were Quote objects.</p>
<p>A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself. A derived class may include the virtual keyword on these functions but is not required to do so.</p>
<h3 id="Dynamic-Binding"><a href="#Dynamic-Binding" class="headerlink" title="Dynamic Binding"></a>Dynamic Binding</h3><p>Through dynamic binding, we can use the same code to process objects of either type <code>Quote</code> or <code>Bulk_quote</code> interchangeably. For example, the following function prints the total price for purchasing the given number of copies of a given book:</p>
<pre><code class="c++">// calculate and print the price for the given number of copies, applying any discounts
double print_total(ostream&amp; os,
    const Quote&amp; item, size_t n) &#123;
    // depending on the type of the object bound to the item parameter
    // calls either Quote::net_price or Bulk_quote::net_price
    double ret = item.net_price(n);
    os &lt;&lt; &quot;ISBN: &quot; &lt;&lt; item.isbn() // calls Quote::isbn
        &lt;&lt; &quot; # sold: &quot; &lt;&lt; n &lt;&lt; &quot; total due: &quot; &lt;&lt; ret &lt;&lt; endl;
    return ret;
&#125;
</code></pre>
<h2 id="Defining-Base-and-Derived-Classes"><a href="#Defining-Base-and-Derived-Classes" class="headerlink" title="Defining Base and Derived Classes"></a>Defining Base and Derived Classes</h2><p>In many, but not all, ways base and derived classes are defined like other classes we have already seen. In this section, we’ll cover the basic features used to define classes related by inheritance.</p>
<h3 id="Defining-a-Base-Class"><a href="#Defining-a-Base-Class" class="headerlink" title="Defining a Base Class"></a>Defining a Base Class</h3><p>We’ll start by completing the definition of our Quote class:</p>
<pre><code class="c++">// in Quote.h
#pragma once
#include&lt;string&gt;
class Quote &#123;
public:
    Quote() = default;
    Quote(std::string s, double p) :bookNo(s), price(p) &#123;&#125;
    virtual ~Quote() = default;

    std::string isbn();
    virtual double net_price(std::size_t n);

private:
    std::string bookNo;
protected:
    double price = 0.0;
&#125;;


// in Quote.cpp
#include &quot;Quote.h&quot;

std::string Quote::isbn() &#123;
    return bookNo;
&#125;

double Quote::net_price(std::size_t n) &#123;
    return n * price;
&#125;
</code></pre>
<p>Derived classes inherit the members of their base class. However, a derived class needs to be able to provide its own definition for operations, such as net_price, that are type dependent. In such cases, the derived class needs to <strong>override</strong> the definition it inherits from the base class, by providing its own definition.</p>
<p>In C++, a base class must distinguish the functions it expects its derived classes to override from those that it expects its derived classes to inherit without change. The base class defines as virtual those functions it expects its derived classes to override.</p>
<p>Member functions that are not declared as virtual are resolved at compile time, not run time. For the <code>isbn</code> member, this is exactly the behavior we want. The <code>isbn</code> function does not depend on the details of a derived type.</p>
<p>A derived class inherits the members defined in its base class. However, the member functions in a derived class may <strong>not necessarily access</strong> the members that are inherited from the base class. Like any other code that uses the base class, a derived class may access the <strong>public</strong> members of its base class but may not access the <strong>private</strong> members. However, sometimes a base class has members that it wants to let its<br>derived classes use while still prohibiting access to those same members by other users. We specify such members after a <strong>protected</strong> access specifier.</p>
<h3 id="Defining-a-Derived-Class"><a href="#Defining-a-Derived-Class" class="headerlink" title="Defining a Derived Class"></a>Defining a Derived Class</h3><p>A derived class must specify from which class(es) it inherits. It does so in its class derivation list, which is a colon followed by a comma-separated list of names of previously defined classes. Each base class name may be preceded by an optional access specifier, which is one of <strong>public</strong>, <strong>protected</strong>, or <strong>private</strong>.</p>
<p>When the derivation is <strong>public</strong>, the public members of the base class become part of the interface of the derived class as well. In addition, we can bind an object of a publicly derived type to a pointer or reference to the base type. Because we used <strong>public</strong> in the derivation list, the interface to <code>Bulk_quote</code> implicitly contains the <code>isbn</code> function, and we may use a Bulk_quote object where a pointer or reference to Quote is expected.</p>
<pre><code class="c++">#pragma once
#include&lt;string&gt;
class Quote &#123;
public:
    Quote() = default;
    // isbn, price , minimum quantity, discount
    Quote(std::string s, double p) :bookNo(s), price(p) &#123;&#125;
    virtual ~Quote() = default;

    std::string isbn();
    virtual double net_price(std::size_t n) const;

private:
    std::string bookNo;
protected:
    double price = 0.0;
&#125;;
</code></pre>
<p>Our <code>Bulk_quote</code> class <strong>inherits</strong> the <code>isbn</code> function and the <code>bookNo</code> and <code>price</code> data members of its Quote base class. It defines its own version of net_price and has two additional data members, <code>min_qty</code> and <code>discount</code>. These members specify the minimum quantity and the discount to apply once that number of copies are purchased.</p>
<p>Derived classes frequently, but not always, override the virtual functions that they inherit. If a derived class does not override a virtual from its base, then, like any other member, the derived class inherits the version defined in its base class.</p>
<p>Although a derived object contains members that it inherits from its base, it <strong>cannot directly initialize</strong> those members. Like any other code that creates an object of the base-class type, a derived class must <strong>use a base-class constructor to initialize its base-class part.</strong></p>
<pre><code class="c++">#include &quot;Bulk_quote.h&quot;

Bulk_quote::Bulk_quote(const std::string&amp; is, double pr, std::size_t min_n, double dis)
    :Quote(is, pr), min_qty(min_n), discount(dis) &#123;
&#125;

double Bulk_quote::net_price(std::size_t n) const &#123;
    if (n &gt;= min_qty) &#123;
        return (1 - discount) * price * n;
    &#125;
    return price * n;
&#125;
</code></pre>
<h3 id="Some-details"><a href="#Some-details" class="headerlink" title="Some details"></a>Some details</h3><p>A derived class is declared like any other class. The declaration contains the class name but does not include its derivation list:</p>
<pre><code class="c++">class Bulk_quote : public Quote; // error: derivation list can&#39;t appear here
class Bulk_quote; // ok: right way to declare a derived class
</code></pre>
<p>A class must be defined, not just declared, before we can use it as a base class:</p>
<pre><code class="c++">class Quote; // declared but not defined
// error: Quote must be defined
class Bulk_quote : public Quote &#123; ... &#125;;
</code></pre>
<p>Sometimes we define a class that we <strong>don’t want others to inherit from</strong>. Or we might define a class for which we don’t want to think about whether it is appropriate as a base class. Under the new standard, we can prevent a class from being used as a base by following the class name with final:</p>
<pre><code class="c++">class NoDerived final &#123; /* */ &#125;; // NoDerived can&#39;t be a base class
</code></pre>
<h3 id="Conversions-and-Inheritance"><a href="#Conversions-and-Inheritance" class="headerlink" title="Conversions and Inheritance"></a>Conversions and Inheritance</h3><p>Ordinarily, we can bind a reference or a pointer only to an object that has the same type as the corresponding reference or pointer or to a type that involves an acceptable const conversion. Classes<br>related by inheritance are an important exception: We can bind a pointer or reference to a base-class type to an object of a type derived from that base class. For example, we can use a <code>Quote&amp;</code> to refer to a <code>Bulk_quote</code> object, and we can assign the address of a <code>Bulk_quote</code> object to a <code>Quote*</code>.</p>
<p>When we use types related by inheritance, we often need to distinguish between the <strong>static type</strong> of a variable or other expression and the <strong>dynamic type</strong> of the object that expression represents. The static type of an expression is always known at compile time—it is the type with which a variable is declared or that an expression yields. The dynamic type is the type of the object in memory that the variable or expression represents. The dynamic type may not be known until run time.</p>
<p>The conversion from derived to base exists because every derived object contains a base-class part to which a pointer or reference of the base-class type can be bound. There is no similar guarantee for base-class objects.</p>
<h2 id="Virtual-Functions"><a href="#Virtual-Functions" class="headerlink" title="Virtual Functions"></a>Virtual Functions</h2><p>When a virtual function is called through a <strong>reference</strong> or <strong>pointer</strong>, the compiler generates code to decide at run time which function to call. The function that is called is the one that corresponds to the dynamic type of the object bound to that pointer or reference.</p>
<p>As an example, you can run the next code in your computer:</p>
<pre><code class="c++">#include&quot;Bulk_quote.h&quot;
#include&lt;iostream&gt;


int main() &#123;
    std::string s = &quot;54742675&quot;;
    Bulk_quote b(s, 10, 8, 0.2);
    // by refreance, out put is 80
    Quote&amp; p1 = b;
    std::cout &lt;&lt; p1.net_price(10) &lt;&lt; std::endl;
    // by pointer, out put is 80
    Quote* p2 = &amp;b;
    std::cout &lt;&lt; p2-&gt;net_price(10) &lt;&lt; std::endl;
    // either, out put is 100
    Quote p3 = b;
    std::cout &lt;&lt; p3.net_price(10) &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>dynamic binding happens only when a virtual function is called through a pointer or a reference.</strong> When we call a virtual function on an expression that has a plain—nonreference and nonpointer—type, that call is bound at compile time.</p>
<p>When a derived class overrides a virtual function, it may, but is not required to, repeat the virtual keyword. Once a function is declared as virtual, it remains virtual in all the derived classes. A derived-class function that overrides an inherited virtual function must have exactly the <strong>same parameter type and return type</strong> as the base-class function that it overrides.</p>
<p>it is legal for a derived class to define a function with the same name as a virtual in its base class but with a different parameter list. The compiler considers such a function to be independent from the base-class function. In such cases, the derived version does not override the version in the base class. In practice, such declarations often are a mistake—the class author intended to override a virtual from the base class but made a mistake in specifying the parameter list.</p>
<p>Under the new standard we can specify override on a virtual function in a derived class. Doing so makes our intention clear and (more importantly) enlists the compiler in finding such problems for us. The compiler will reject a program if a function marked override does not override an existing virtual function:</p>
<pre><code class="c++">struct B &#123;
    virtual void f1(int) const;
    virtual void f2();
    void f3();
&#125;;
struct D1 : B &#123;
    void f1(int) const override; // ok: f1 matches f1 in the base
    void f2(int) override; // error: B has no f2(int) function
    void f3() override; // error: f3 not virtual
    void f4() override; // error: B doesn&#39;t have a function named f4
&#125;;
</code></pre>
<p>We can also designate a function as final. Any attempt to override a function that has been defined as final will be flagged as an error:</p>
<pre><code class="c++">struct D2 : B &#123;
    // inherits f2() and f3() from B and overrides f1(int)
    void f1(int) const final; // subsequent classes can&#39;t override f1(int)
&#125;;
struct D3 : D2 &#123;
    void f2(); // ok: overrides f2 inherited from the indirect base,B
    void f1(int) const; // error: D2 declared f2 as final
&#125;;
</code></pre>
<h3 id="Some-detail"><a href="#Some-detail" class="headerlink" title="Some detail"></a>Some detail</h3><p>Like any other function, a virtual function can have default arguments. If a call uses a default argument, the value that is used is the one defined by the static type through which the function is called. That is, when a call is made through a reference or pointer to base, the <strong>default argument(s) will be those defined in the base class</strong>. The base-class arguments will be used even when the derived version of the function is run. In this case, the derived function will be passed the default arguments defined for the base-class version of the function. If the derived function relies on being passed different arguments, the<br>program will not execute as expected.</p>
<p>In some cases, we want to <strong>prevent</strong> dynamic binding of a call to a virtual function; we want to force the call to use a particular version of that virtual. We can use the scope operator to do so. For example, this code:</p>
<pre><code class="c++">Quote* p2 = &amp;b;
std::cout &lt;&lt; p2-&gt;Quote::net_price(10) &lt;&lt; std::endl;
</code></pre>
<h2 id="Abstract-Base-Classes"><a href="#Abstract-Base-Classes" class="headerlink" title="Abstract Base Classes"></a>Abstract Base Classes</h2><p>Imagine that we want to extend our bookstore classes to support several discount strategies. In addition to a bulk discount, we might offer a discount for purchases up to a certain quantity and then charge the full price thereafter. Or we might offer a discount for purchases above a certain limit but not for purchases up to that limit.</p>
<p>Each of these discount strategies is the same in that it requires a quantity and a discount amount. We might support these differing strategies by defining a new class named <code>Disc_quote</code> to store the quantity and the discount amount. Classes, such as <code>Bulk_item</code>, that represent a specific discount strategy will inherit from <code>Disc_quote</code>. Each of the derived classes will implement its discount strategy by defining its own version of <code>net_price</code>.</p>
<p>Before we can define our <code>Disc_Quote</code> class, we have to decide what to do about <code>net_price</code>. Our <code>Disc_quote</code> class doesn’t correspond to any particular discount strategy; there is no meaning to ascribe to <code>net_price</code> for this class. We could define <code>Disc_quote</code> without its own version of <code>net_price</code>. In this case, <code>Disc_quote</code> would inherit <code>net_price</code> from <code>Quote</code>.</p>
<p>However, this design would make it possible for our users to write nonsensical code. A user could create an object of type <code>Disc_quote</code> by supplying a quantity and a discount rate. Passing that <code>Disc_quote</code> object to a function such as <code>print_total</code> would use the Quote version of <code>net_price</code>. The calculated price would not include the discount that was supplied when the object was created. That state of affairs<br>makes no sense.</p>
<h3 id="Pure-Virtual-Functions"><a href="#Pure-Virtual-Functions" class="headerlink" title="Pure Virtual Functions"></a>Pure Virtual Functions</h3><p>Thinking about the question in this detail reveals that our problem is not just that we don’t know how to define net_price. In practice, we’d like to prevent users from creating Disc_quote objects at all.</p>
<p>We can enforce this design intent—and make it clear that there is no meaning for net_price—by defining net_price as a pure virtual function. Unlike ordinary virtuals, a pure virtual function does not have to be defined. We specify that a virtual function is a pure virtual by writing = 0 in place of a function body.</p>
<pre><code class="c++">#pragma once
#include &quot;Quote.h&quot;
class Disc_Quote : public Quote &#123;
public:
    Disc_Quote() = default;
    Disc_Quote(const std::string&amp; book, double price,
        std::size_t qty, double disc) :
        Quote(book, price),
        quantity(qty), discount(disc) &#123;
    &#125;
    double net_price(std::size_t) const = 0;
protected:
    std::size_t quantity = 0; // purchase size for the discount to apply
    double discount = 0.0; // fractional discount to apply
&#125;;
</code></pre>
<p>A class containing (or inheriting without overriding) a pure virtual function is an <strong>abstract base class</strong>. An abstract base class defines an interface for subsequent classes to override. <strong>We cannot (directly) create objects of a type that is an abstract base class</strong>. Because <code>Disc_quote</code> defines <code>net_price</code> as a pure virtual, we cannot define objects of type <code>Disc_quote</code>. We can define objects of classes that inherit from <code>Disc_quote</code>, so long as those classes override <code>net_price</code>:</p>
<pre><code class="c++">Disc_Quote discounted; // error: can&#39;t define a Disc_quote object
</code></pre>
<h3 id="A-Derived-Class-Constructor-Initializes-Its-Direct-Base-Class-Only"><a href="#A-Derived-Class-Constructor-Initializes-Its-Direct-Base-Class-Only" class="headerlink" title="A Derived Class Constructor Initializes Its Direct Base Class Only"></a>A Derived Class Constructor Initializes Its Direct Base Class Only</h3><p>Now we can reimplement <code>Bulk_quote</code> to inherit from <code>Disc_quote</code> rather than inheriting directly from <code>Quote</code>:</p>
<pre><code class="c++">#pragma once
#include &quot;Disc_Quote.h&quot;
class Bulk_quote : public Disc_Quote &#123;
public:
    Bulk_quote() = default;
    // isbn, price , minimum quantity, discount
    Bulk_quote(const std::string&amp;, double, std::size_t, double);
    double net_price(std::size_t n) const override;
&#125;;

#include &quot;Bulk_quote.h&quot;

// isbn, price , minimum quantity, discount
Bulk_quote::Bulk_quote(const std::string&amp; is, double pr, std::size_t min_n, double dis)
    :Disc_Quote(is, pr, min_n, dis) &#123;
&#125;

double Bulk_quote::net_price(std::size_t n) const &#123;
    if (n &gt;= quantity) &#123;
        return (1 - discount) * price * n;
    &#125;
    return price * n;
&#125;
</code></pre>
<h2 id="Access-Control-and-Inheritance"><a href="#Access-Control-and-Inheritance" class="headerlink" title="Access Control and Inheritance"></a>Access Control and Inheritance</h2><p>Just as each class controls the initialization of its own members, each class also controls whether its members are accessible to a derived class.</p>
<h3 id="protected-Members"><a href="#protected-Members" class="headerlink" title="protected Members"></a>protected Members</h3><p>As we’ve seen, a class uses protected for those members that it is willing to share with its derived classes but wants to protect from general access. The protected specifier can be thought of as a blend of private and public:</p>
<ul>
<li>Like private, protected members are inaccessible to users of the class.</li>
<li>Like public, protected members are accessible to members and friends of classes derived from this class.</li>
</ul>
<p>In addition, protected has another important property:</p>
<ul>
<li>A derived class member or friend may access the protected members of the base class only through a derived object. The derived class has no special access to the protected members of base-class objects.</li>
</ul>
<h3 id="public-private-and-protected-Inheritance"><a href="#public-private-and-protected-Inheritance" class="headerlink" title="public, private, and protected Inheritance"></a>public, private, and protected Inheritance</h3><p>Access to a member that a class inherits is controlled by a combination of the access specifier for that member in the base class, and the access specifier in the derivation list of the derived class. As an example, consider the following hierarchy:</p>
<pre><code class="c++">class Base &#123;
public:
    void pub_mem(); // public member
protected:
    int prot_mem; // protected member
private:
    char priv_mem; // private member
&#125;;
struct Pub_Derv : public Base &#123;
    // ok: derived classes can access protected members
    int f() &#123; return prot_mem; &#125;
    // error: private members are inaccessible to derived classes
    char g() &#123; return priv_mem; &#125;
&#125;;
struct Priv_Derv : private Base &#123;
    // private derivation doesn&#39;t affect access in the derived class
    int f1() const &#123; return prot_mem; &#125;
&#125;;
</code></pre>
<p>The derivation access specifier has no effect on whether members (and friends) of a derived class may access the members of its own direct base class. Access to the members of a base class is controlled by the access specifiers in the base class itself. Both <code>Pub_Derv</code> and <code>Priv_Derv</code> may access the protected member <code>prot_mem</code>. Neither may access the private member <code>priv_mem</code>.</p>
<p>The <strong>purpose</strong> of the derivation access specifier is to control the access that users of the derived class—including other classes derived from the derived class—have to the members inherited from Base:</p>
<pre><code class="c++">Pub_Derv d1; // members inherited from Base are public
Priv_Derv d2; // members inherited from Base are private
d1.pub_mem(); // ok: pub_mem is public in the derived class
d2.pub_mem(); // error: pub_mem is private in the derived class
</code></pre>
<p>The derivation access specifier used by a derived class also controls access from classes that inherit from that derived class:</p>
<pre><code class="c++">struct Derived_from_Public : public Pub_Derv &#123;
    // ok: Base::prot_mem remains protected in Pub_Derv
    int use_base() &#123; return prot_mem; &#125;
&#125;;
struct Derived_from_Private : public Priv_Derv &#123;
    // error: Base::prot_mem is private in Priv_Derv
    int use_base() &#123; return prot_mem; &#125;
&#125;;
</code></pre>
<p>Classes derived from <code>Pub_Derv</code> may access <code>prot_mem</code> from <code>Base</code> because that member remains a protected member in <code>Pub_Derv</code>. In contrast, classes derived from <code>Priv_Derv</code> have no such access. To them, all the members that <code>Priv_Derv</code> inherited from Base are <code>private</code>.</p>
<h3 id="Friendship-and-Inheritance"><a href="#Friendship-and-Inheritance" class="headerlink" title="Friendship and Inheritance"></a>Friendship and Inheritance</h3><p>Just as friendship is not transitive, friendship is also not inherited. Friends of the base have no special access to members of its derived classes, and friends of a derived class have no special access to the base class:</p>
<pre><code class="c++">class Base &#123;
    // added friend declaration; other members as before
    friend class Pal; // Pal has no access to classes derived from Base
&#125;;
class Pal &#123;
public:
    int f(Base b) &#123; return b.prot_mem; &#125; // ok: Pal is a friend of Base
    int f2(Sneaky s) &#123; return s.j; &#125; // error: Pal not friend of Sneaky
    // access to a base class is controlled by the base class, even inside a derived object
    int f3(Sneaky s) &#123; return s.prot_mem; &#125; // ok: Pal is a friend
&#125;;
</code></pre>
<h3 id="Exempting-Individual-Members"><a href="#Exempting-Individual-Members" class="headerlink" title="Exempting Individual Members"></a>Exempting Individual Members</h3><p>Sometimes we need to change the access level of a name that a derived class inherits. We can do so by providing a using declaration:</p>
<pre><code class="c++">class Base &#123;
public:
    std::size_t size() const &#123; return n; &#125;
protected:
    std::size_t n;
&#125;;
class Derived : private Base &#123; // note: private inheritance
public:
    // maintain access levels for members related to the size of the object
    using Base::size;
protected:
    using Base::n;
&#125;;
</code></pre>
<p>Because Derived uses <strong>private</strong> inheritance, the inherited members, size and n, are (by default) private members of Derived. The using declarations adjust the accessibility of these members. Users of Derived can <strong>access</strong> the size member, and classes subsequently derived from Derived can access n.</p>
<p>In previous we saw that classes defined with the struct and class keywords have different default access specifiers. Similarly, the default derivation specifier depends on which keyword is used to define a derived class. By default, a derived class defined with the <strong>class</strong> keyword has <strong>private</strong> inheritance; a derived class defined with <strong>struct</strong> has <strong>public</strong> inheritance</p>
<h2 id="Class-Scope-under-Inheritance"><a href="#Class-Scope-under-Inheritance" class="headerlink" title="Class Scope under Inheritance"></a>Class Scope under Inheritance</h2><p>Each class defines its own scope within which its members are defined. Under inheritance, the scope of a derived class is <strong>nested inside the scope of its base classes</strong>. If a name is unresolved within the scope of the derived class, the enclosing base-class scopes are searched for a definition of that name.</p>
<h3 id="Name-Lookup-Happens-at-Compile-Time"><a href="#Name-Lookup-Happens-at-Compile-Time" class="headerlink" title="Name Lookup Happens at Compile Time"></a>Name Lookup Happens at Compile Time</h3><p>The static type of an object, reference, or pointer determines which members of that object are visible. Even when the static and dynamic types might differ (as can happen when a reference or pointer to a base class is used), the static type determines what members can be used. As an example, we might add a member to the Disc_quote class that returns a pair holding the minimum (or maximum) quantity and the discounted price:</p>
<pre><code class="c++">class Disc_quote : public Quote &#123;
public:
    std::pair&lt;size_t, double&gt; discount_policy() const
    &#123; return &#123;quantity, discount&#125;; &#125;
    // other members as before
&#125;;
</code></pre>
<p>We can use <code>discount_policy</code> only through an object, pointer, or reference of type <code>Disc_quote</code> or of a class derived from <code>Disc_quote</code>:</p>
<pre><code class="c++">Bulk_quote bulk;
Bulk_quote *bulkP = &amp;bulk; // static and dynamic types are the same
Quote *itemP = &amp;bulk; // static and dynamic types differ
bulkP-&gt;discount_policy(); // ok: bulkP has type Bulk_quote*
itemP-&gt;discount_policy(); // error: itemP has type Quote*
</code></pre>
<p>Even though bulk has a member named discount_policy, that member is not visible through itemP. The type of itemP is a pointer to Quote, which means that the search for discount_policy starts in class Quote. The Quote class has no member named discount_policy, so we cannot call that member on an object, reference, or pointer of type Quote.</p>
<h3 id="Name-Collisions-and-Inheritance"><a href="#Name-Collisions-and-Inheritance" class="headerlink" title="Name Collisions and Inheritance"></a>Name Collisions and Inheritance</h3><p>Like any other scope, a derived class can reuse a name defined in one of its direct or indirect base classes. As usual, names defined in an inner scope hide uses of that name in the outer scope:</p>
<pre><code class="c++">struct Base &#123;
    Base() : mem(0) &#123;&#125;
public:
    int mem;
&#125;;
struct Derived : Base &#123;
    Derived(int i) : mem(i) &#123;&#125; // initializes Derived::mem to i
    // Base::mem is default initialized
    int get_mem() &#123; return mem; &#125; // returns Derived::mem
public:
    int mem; // hides mem in the base
&#125;;
</code></pre>
<p>We use the <code>::</code> select scope:</p>
<pre><code class="c++">Derived p(19);
std::cout &lt;&lt; p.mem &lt;&lt; std::endl;      // output is 19
std::cout &lt;&lt; p.Base::mem &lt;&lt; std::endl;// output is 0
</code></pre>
<p>As we’ve seen, functions declared in an inner scope do not overload functions declared in an outer scope. As a result, functions defined in a derived class do not overload members defined in its base class(es). As in any other scope, if a member in a derived class (i.e., in an inner scope) has the same name as a base class member (i.e., a name defined in an outer scope), then the derived member hides the base-class member within the scope of the derived class. The base member is hidden even if the functions have different parameter lists:</p>
<pre><code class="c++">struct Base &#123;
    int memfcn();
&#125;;
struct Derived : Base &#123;
    int memfcn(int); // hides memfcn in the base
&#125;;
Derived d; Base b;
b.memfcn(); // calls Base::memfcn
d.memfcn(10); // calls Derived::memfcn
d.memfcn(); // error: memfcn with no arguments is hidden
d.Base::memfcn(); // ok: calls Base::memfcn
</code></pre>
<h3 id="Virtual-Functions-and-Scope"><a href="#Virtual-Functions-and-Scope" class="headerlink" title="Virtual Functions and Scope"></a>Virtual Functions and Scope</h3><p>We can now understand why virtual functions must have the same parameter list in the base and derived classes. If the base and derived members took arguments that differed from one another, there would be no way to call the derived version through a reference or pointer to the base class. For example:</p>
<pre><code class="c++">class Base &#123;
public:
    virtual int fcn();
&#125;;
class D1 : public Base &#123;
public:
    // hides fcn in the base; this fcn is not virtual
    // D1 inherits the definition of Base::fcn()
    int fcn(int); // parameter list differs from fcn in Base
    virtual void f2(); // new virtual function that does not exist in Base
&#125;;
class D2 : public D1 &#123;
public:
    int fcn(int); // nonvirtual function hides D1::fcn(int)
    int fcn(); // overrides virtual fcn from Base
    void f2(); // overrides virtual f2 from D1
&#125;;
</code></pre>
<h2 id="Constructors-and-Copy-Control"><a href="#Constructors-and-Copy-Control" class="headerlink" title="Constructors and Copy Control"></a>Constructors and Copy Control</h2><p>Like any other class, a class in an inheritance hierarchy controls what happens when objects of its type are created, copied, moved, assigned, or destroyed. As for any other class, if a class (base or derived) does not itself define one of the copy-control operations, the compiler will synthesize that operation. Also, as usual, the synthesized version of any of these members might be a deleted function.</p>
<h3 id="Virtual-Destructors"><a href="#Virtual-Destructors" class="headerlink" title="Virtual Destructors"></a>Virtual Destructors</h3><p>The primary direct impact that inheritance has on copy control for a base class is that a base class generally should define a virtual destructor. The destructor needs to be virtual to allow objects in the inheritance hierarchy to be dynamically allocated.</p>
<p>Recall that the destructor is run when we delete a pointer to a dynamically allocated object. If that pointer points to a type in an inheritance hierarchy, it is possible that the static type of the pointer might differ from the dynamic type of the object being destroyed. For example, if we delete a pointer of type Quote*, that pointer might point at a Bulk_quote object.</p>
<p>If the pointer points at a Bulk_quote, the compiler has to know that it should run the Bulk_quote destructor. As with any other function, we arrange to run the proper destructor by defining the destructor as virtual in the base class.</p>
<p>Like any other virtual, the virtual nature of the destructor is inherited. Thus, classes derived from Quote have virtual destructors, whether they use the synthesized destructor or define their own version. So long as the base class destructor is virtual, when we delete a pointer to base, the correct destructor will be run:</p>
<pre><code class="c++">Quote *itemP = new Quote; // same static and dynamic type
delete itemP; // destructor for Quote called
itemP = new Bulk_quote; // static and dynamic types differ
delete itemP; // destructor for Bulk_quote called
</code></pre>
<h3 id="Synthesized-Copy-Control-and-Inheritance"><a href="#Synthesized-Copy-Control-and-Inheritance" class="headerlink" title="Synthesized Copy Control and Inheritance"></a>Synthesized Copy Control and Inheritance</h3><p>The synthesized copy-control members in a base or a derived class execute like any other synthesized constructor, assignment operator, or destructor: They memberwise initialize, assign, or destroy the members of the class itself. In addition, these synthesized members initialize, assign, or destroy the direct base part of an object by using the corresponding operation from the base class.</p>
<p>the synthesized <code>Bulk_quote</code> copy constructor uses the (synthesized) <code>Disc_quote</code> copy constructor, which uses the (synthesized) <code>Quote</code> copy constructor. The Quote copy constructor copies the bookNo and price members; and the <code>Disc_Quote</code> copy constructor copies the qty and discount members.</p>
<p>The synthesized default constructor, or any of the copy-control members of either a base or a derived class, may be defined as deleted for the same reasons as in any other class:</p>
<ol>
<li>If the default constructor, copy constructor, copy-assignment operator, or destructor in the base class is deleted or inaccessible, then the corresponding member in the derived class is defined as deleted, because the compiler can’t use the base-class member to construct, assign, or destroy the base-class part of the object.</li>
<li>If the base class has an inaccessible or deleted destructor, then the synthesized default and copy constructors in the derived classes are defined as deleted, because there is no way to destroy the base part of the derived object.</li>
<li>As usual, the compiler will not synthesize a deleted move operation. If we use =default to request a move operation, it will be a deleted function in the derived if the corresponding operation in the base is deleted or inaccessible,because the base class part cannot be moved. The move constructor will also be deleted if the base class destructor is deleted or inaccessible.</li>
</ol>
<pre><code class="c++">class B &#123;
public:
    B();
    B(const B&amp;) = delete;
    // other members, not including a move constructor
&#125;;
class D : public B &#123;
    // no constructors
&#125;;
D d; // ok: D&#39;s synthesized default constructor uses B&#39;s default constructor
D d2(d); // error: D&#39;s synthesized copy constructor is deleted
D d3(std::move(d)); // error: implicitly uses D&#39;s deleted copy constructor
</code></pre>
<h3 id="Derived-Class-Copy-Control-Members"><a href="#Derived-Class-Copy-Control-Members" class="headerlink" title="Derived-Class Copy-Control Members"></a>Derived-Class Copy-Control Members</h3><p>When we define a copy or move constructor for a derived class, we ordinarily use the corresponding base-class constructor to initialize the base part of the object:</p>
<pre><code class="c++">class Base &#123; /* ... */ &#125;;
class D : public Base &#123;
public:
    // by default, the base class default constructor initializes the base part of an object
    // to use the copy or move constructor, we must explicitly call that
    // constructor in the constructor initializer list
    D(const D&amp; d) : Base(d) // copy the base members
        /* initializers for members of D */ &#123; /* ... */
    &#125;
    D(D&amp;&amp; d) : Base(std::move(d)) // move the base members
        /* initializers for members of D */ &#123; /* ... */
    &#125;
&#125;;
</code></pre>
<p>Like the copy and move constructors, a derived-class assignment operator, must assign its base part explicitly:</p>
<pre><code class="c++">// Base::operator=(const Base&amp;) is not invoked automatically
D&amp; D::operator=(const D&amp; rhs) &#123;
    Base::operator=(rhs); // assigns the base part
    // assign the members in the derived class, as usual,
    // handling self-assignment and freeing existing resources as appropriate
    return *this;
&#125;
</code></pre>
<p>Recall that the data members of an object are implicitly destroyed after the destructor body completes. Similarly, the base-class parts of an object are also implicitly destroyed. As a result, unlike the constructors and assignment operators, <strong>a derived destructor is responsible only for destroying the resources allocated by the derived class</strong>:</p>
<pre><code class="c++">class D: public Base &#123;
public:
    // Base::~Base invoked automatically
     ~D() &#123; /* do what it takes to clean up derived members */ &#125;
&#125;;
</code></pre>
<p>Objects are destroyed in the opposite order from which they are constructed: <strong>The derived destructor is run first</strong>, and then the <strong>base-class destructors are invoked</strong>, back up through the inheritance hierarchy.</p>
<h3 id="Inherited-Constructors"><a href="#Inherited-Constructors" class="headerlink" title="Inherited Constructors"></a>Inherited Constructors</h3><p>Under the new standard, a derived class can reuse the constructors defined by its direct base class. Although, as we’ll see, such constructors are not inherited in the normal sense of that term, it is nonetheless common to refer to such constructors as “inherited.” For the same reasons that a class may initialize only its direct base class, a class may inherit constructors only from its direct base. A class cannot inherit the default, copy, and move constructors. If the derived class does not directly define these constructors, the compiler synthesizes them as usual.</p>
<p>A derived class inherits its base-class constructors by providing a using declaration that names its (direct) base class. As an example, we can redefine our <code>Bulk_quote</code> class to inherit its constructors from <code>Disc_quote</code>:</p>
<pre><code class="c++">class Bulk_quote : public Disc_quote &#123;
public:
    using Disc_quote::Disc_quote; // inherit Disc_quote&#39;s constructors
    double net_price(std::size_t) const;
&#125;;
</code></pre>
<h2 id="Containers-and-Inheritance"><a href="#Containers-and-Inheritance" class="headerlink" title="Containers and Inheritance"></a>Containers and Inheritance</h2><p>When we use a container to store objects from an inheritance hierarchy, we generally must store those objects indirectly. We cannot put objects of types related by inheritance directly into a container, because there is no way to define a container that holds elements of differing types.</p>
<p>As an example, assume we want to define a vector to hold several books that a customer wants to buy. It should be easy to see that we can’t use a vector that holds <code>Bulk_quote</code> objects. We can’t convert <code>Quote</code> objects to <code>Bulk_quote</code>, so we wouldn’t be able to put Quote objects into that vector.</p>
<p>It may be somewhat less obvious that we also can’t use a vector that holds objects of type Quote. In this case, we can put Bulk_quote objects into the container. However, those objects would no longer be Bulk_quote objects:</p>
<pre><code class="c++">vector&lt;Quote&gt; basket;
basket.push_back(Quote(&quot;0-201-82470-1&quot;, 50));
// ok, but copies only the Quote part of the object into basket
basket.push_back(Bulk_quote(&quot;0-201-54848-8&quot;, 50, 10, .25));
// calls version defined by Quote, prints 750, i.e., 15 * $50
cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;
</code></pre>
<p>The elements in basket are <strong>Quote</strong> objects. When we add a <strong>Bulk_quote</strong> object to the vector its derived part is ignored.</p>
<p>When we need a container that holds objects related by inheritance, we typically define the container to hold pointers (preferably smart pointers) to the base class. As usual, the dynamic type of the object to which those pointers point might be the base-class type or a type derived from that base:</p>
<pre><code class="c++">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;
basket.push_back(make_shared&lt;Quote&gt;(&quot;0-201-82470-1&quot;, 50));
basket.push_back(
make_shared&lt;Bulk_quote&gt;(&quot;0-201-54848-8&quot;, 50, 10, .25));
// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount
cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;
</code></pre>
<h3 id="Writing-a-Basket-Class"><a href="#Writing-a-Basket-Class" class="headerlink" title="Writing a Basket Class"></a>Writing a Basket Class</h3><p>One of the ironies of object-oriented programming in C++ is that we cannot use objects directly to support it. Instead, we must use pointers and references. Because pointers impose complexity on our programs, we often define auxiliary classes to help manage that complexity. We’ll start by defining a class to represent a basket:</p>
<pre><code class="c++">// Basket.h
#pragma once
#include&lt;memory&gt;
#include&quot;Quote.h&quot;
#include&lt;set&gt;

class Basket &#123;
public:
    // Basket uses synthesized default constructor and copy-control members
    void add_item(const std::shared_ptr&lt;Quote&gt;&amp; sale) &#123;
        items.insert(sale);
    &#125;
    // prints the total price for each book and the overall total for all items in the basket
    double total_receipt(std::ostream&amp;) const;
private:
    static bool compare(const std::shared_ptr&lt;Quote&gt;&amp; lhs,
        const std::shared_ptr&lt;Quote&gt;&amp; rhs) &#123;
        return lhs-&gt;isbn() &lt; rhs-&gt;isbn();
    &#125;
    std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(compare)*&gt; items&#123; compare &#125;;
&#125;;
</code></pre>
<p>The elements in our multiset are <code>shared_ptrs</code> and there is no less-than operator for <code>shared_ptr</code>. As a result, we must provide our own comparison operation to order the elements. Here, we define a private<br>static member, named compare, that compares the <code>isbns</code> of the objects to which the <code>shared_ptrs</code> point. We initialize our multiset to use this comparison function through an in-class initializer.</p>
<p>The Basket class defines only two operations. We defined the <code>add_item</code> member inside the class. That member takes a shared_ptr to a dynamically allocated Quote and puts that shared_ptr into the multiset. The second member, <code>total_receipt</code>, prints an itemized bill for the contents of the basket and returns the price for all the items in the basket:</p>
<pre><code class="c++">// Basket.cpp
#include &quot;Basket.h&quot;

double print_total(std::ostream&amp; os,
    const Quote&amp; item, size_t n) &#123;
    // depending on the type of the object bound to the item parameter
    // calls either Quote::net_price or Bulk_quote::net_price
    double ret = item.net_price(n);
    os &lt;&lt; &quot;ISBN: &quot; &lt;&lt; item.isbn() // calls Quote::isbn
        &lt;&lt; &quot; # sold: &quot; &lt;&lt; n &lt;&lt; &quot; total due: &quot; &lt;&lt; ret &lt;&lt; std::endl;
    return ret;
&#125;

double Basket::total_receipt(std::ostream&amp; os) const &#123;
    double sum = 0.0;
    // holds the running total
    // iter refers to the first element in a batch of elements with the same ISBN
    // upper_bound returns an iterator to the element just past the end of that batch
    for (auto iter = items.cbegin();
        iter != items.cend();
        iter = items.upper_bound(*iter)) &#123;
        // we know there&#39;s at least one element with this key in the Basket
        // print the line item for this book
        sum += print_total(os, **iter, items.count(*iter));
    &#125;
    os &lt;&lt; &quot;Total Sale: &quot; &lt;&lt; sum &lt;&lt; std::endl; // print the final overall total
    return sum;
&#125;
</code></pre>
<p>The interesting bit is the “increment” expression in the for. Rather than the usual loop that reads each element, we advance iter to refer to the next key. We skip over all the elements that match the current key by calling upper_bound. The call to upper_bound returns the iterator that refers to the element just past the last one with the same key as in iter. The iterator we get back denotes either the end of the set or the next book.</p>
<p>Users of Basket still have to deal with dynamic memory, because add_item takes a <code>shared_ptr</code>. As a result, users have to write code such as</p>
<pre><code class="c++">Basket b;
b.add_item(std::make_shared&lt;Quote&gt;(&quot;111&quot;, 50));
b.add_item(std::make_shared&lt;Quote&gt;(&quot;124&quot;, 60));
</code></pre>
<p>Our next step will be to redefine <code>add_item</code> so that it takes a <code>Quote</code> object instead of a <code>shared_ptr</code>. This new version of add_item will handle the memory allocation so that our users no longer need to do so. We’ll define two versions, one that will copy its given object and the other that will move from it:</p>
<pre><code class="c++">void add_item(const Quote&amp; sale); // copy the given object
void add_item(Quote&amp;&amp; sale); // move the given object
</code></pre>
<p>The only problem is that add_item doesn’t know what type to allocate. When it does its memory allocation, add_item will copy (or move) its sale parameter. We’ll solve this problem by giving our Quote classes a virtual member that allocates a copy of itself.</p>
<pre><code class="c++">class Quote &#123;
public:
    // virtual function to return a dynamically allocated copy of itself
    // these members use reference qualifiers; see §13.6.3 (p. 546)
    virtual Quote* clone() const&amp; &#123;
        return new
            Quote(*this);
    &#125;
    virtual Quote* clone()&amp;&amp; &#123;
        return new
            Quote(std::move(*this));
    &#125;
    // other members as before
&#125;;
class Bulk_quote : public Quote &#123;
    Bulk_quote* clone() const&amp; &#123;
        return new
            Bulk_quote(*this);
    &#125;
    Bulk_quote* clone()&amp;&amp; &#123;
        return new
            Bulk_quote(std::move(*this));
    &#125;
    // other members as before
&#125;;
</code></pre>
<p>Using clone, it is easy to write our new versions of add_item:</p>
<pre><code class="c++">class Basket &#123;
public:
    void add_item(const Quote&amp; sale) // copy the given object
    &#123;
        items.insert(std::shared_ptr&lt;Quote&gt;(sale.clone()));
    &#125;
    void add_item(Quote&amp;&amp; sale) // move the given object
    &#123;
        items.insert(
            std::shared_ptr&lt;Quote&gt;(std::move(sale).clone()));
    &#125;
    // other members as before
&#125;;
</code></pre>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://morning.eu.org/images/custom/donate/404.jpg"></li>
                <li class="wechat-code"><img src="https://morning.eu.org/images/custom/donate/404.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2021/12/12/c++%20c12/" rel="prev">
              <div class="background">
                <img class="lazyload" src="" data-src="/images/cover/(4).jpg.webp" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" src="/images/cover/(4).jpg.webp">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                (ch12) Templates and Generic Programming (Not completed yet)</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2021/12/10/c++%20c10/" rel="next">
              <div class="background">
                <img class="lazyload" src="" data-src="/images/cover/(2).jpg.webp" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" src="/images/cover/(2).jpg.webp">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                (ch10) Overloaded Operations and Conversions</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
	window.onload = function(){
		var valine = new Valine();
		valine.init({
			el: '#vcomments',
			appId: "EAyicHJhXmxJNEeuhACVujd4-gzGzoHsz",
			appKey: "09Tjj4It5DOhgboduuM40u7y",
			avatar: 'wavatar',
			path: window.location.pathname,
			placeholder: "有什么想说的吗.."
		})
	}
</script>




      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="morning.eu.org" class="profile gravatar"><img src="/images/custom/avatar.jpg" itemprop="image" alt="Noah" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="morning.eu.org" itemprop="url" rel="author">Noah</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>life is perfact</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Noah Bishop<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://morning.eu.org/images/other/wordpress-rotating-ball-o.svg">
        <img src="https://morning.eu.org/images/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2019-2023</p>
    </div>
    <div class="footer-device">
      <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank"
            style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i
            class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a
            href="https://2heng.xin/" target="_blank"
            style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a
            href="https://www.hojun.cn/" target="_blank"
            style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo,
          Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div>
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
  /* <![CDATA[ */
  if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
    var Poi = { "pjax": "1", "movies": { "url": "", "name": "", "live": "close" }, "windowheight": "fixed", "codelamp": "close", "ajaxurl": "", "order": "asc", "formpostion": "bottom" };
  } else {
    var Poi = { "pjax": "1", "movies": { "url": "", "name": "", "live": "open" }, "windowheight": "auto", "codelamp": "close", "ajaxurl": "", "order": "asc", "formpostion": "bottom" };
  }
/* ]]> */

</script>
<script>
  $(document).ready(function () {
    if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
      if ($(".pattern-center").length > 0) { //有图的情况
        tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
        });
      } else {
        tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
        });
      }
      var offsetTop = $('.toc').offset().top - 95;
      window.onscroll = function () {
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop >= offsetTop) {
          $('.toc').addClass('toc-fixed');
        } else {
          $('.toc').removeClass('toc-fixed');
        }
      }
    }
  });
</script>
    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://morning.eu.org/images/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">桜荘そのうさぎ</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/NoahBishop" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://t.me/mega1037" class="fa fa-telegram" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
        <a href="https://mailto:beiloquuw@gamil.com" class="fa fa-google" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/%E6%8A%80%E6%9C%AF/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/%E7%94%9F%E6%B4%BB/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%B5%84%E6%BA%90/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/%E9%9A%8F%E6%83%B3/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/tags/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-tag" aria-hidden="true"></i>
            标签
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="7225712775"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="true"

    loop="all"

    order="random"

    preload="auto"

    volume="0.5"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>