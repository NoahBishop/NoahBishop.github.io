{"meta":{"title":"うさぎの手帳","subtitle":null,"description":null,"author":"Noah Bishop","url":"https://NoahBishop.github.io"},"pages":[{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2023-04-20T11:21:42.035Z","comments":false,"path":"donate/index.html","permalink":"https://noahbishop.github.io/donate/index.html","excerpt":"","text":"","keywords":"ありがとうございます~"},{"title":"comment","date":"2021-12-20T15:13:48.000Z","updated":"2023-04-20T11:24:28.233Z","comments":true,"path":"comment/index.html","permalink":"https://noahbishop.github.io/comment/index.html","excerpt":"","text":"Welocme 有什么想说的可以给我留言哦！","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-04-20T11:28:10.102Z","comments":true,"path":"links/index.html","permalink":"https://noahbishop.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://noahbishop.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2023-04-21T08:42:45.734Z","comments":true,"path":"tags/index.html","permalink":"https://noahbishop.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-12-12T14:14:36.000Z","updated":"2023-02-04T13:01:14.496Z","comments":false,"path":"about/index.html","permalink":"https://noahbishop.github.io/about/index.html","excerpt":"","text":"[さくら荘のうさぎ] 与&nbsp; Noah&nbsp; （ 真（ま）中（なか） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"music","date":"2021-12-18T15:14:28.000Z","updated":"2023-02-04T12:52:09.720Z","comments":false,"path":"music/index.html","permalink":"https://noahbishop.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2021-12-18T14:53:25.000Z","updated":"2023-04-20T11:22:08.758Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://noahbishop.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro 现在是基于Hexo主题Sakura的二次修改，感谢Hexo主题Sakura作者honjun","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"(ch8) Dynamic Memory","slug":"c++ c8","date":"2021-12-25T13:52:45.000Z","updated":"2023-04-21T08:45:06.232Z","comments":true,"path":"2021/12/25/c++ c8/","link":"","permalink":"https://noahbishop.github.io/2021/12/25/c++%20c8/","excerpt":"","text":"Dynamic MemoryThe programs we’ve written so far have used objects that have well-defined lifetimes. Global objects are allocated at program start-up and destroyed when the program ends. Local, automatic objects are created and destroyed when the block in which they are defined is entered and exited. Local static objects are allocated before their first use and are destroyed when the program ends. In addition to supporting automatic and static objects, C++ lets us allocate objects dynamically. Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed. Our programs have used only static or stack memory. Static memory is used for local static objects, for class static data members, and for variables defined outside any function. Stack memory is used for no-static objects defined inside functions. Objects allocated in static or stack memory are automatically created and destroyed by the compiler. Stack objects exist only while the block in which they are defined is executing; static objects are allocated before they are used, and they are destroyed when the program ends. In addition to static or stack memory, every program also has a pool of memory that it can use. This memory is referred to as the free store or heap. Programs use the heap for objects that they dynamically allocate—that is, for objects that the program allocates at run time. The program controls the lifetime of dynamic objects; our code must explicitly destroy such objects when they are no longer needed. Dynamic Memory and Smart PointersIn C++, dynamic memory is managed through a pair of operators: new, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and delete, which takes a pointer to a dynamic object, destroys that object, and frees the associated memory. Dynamic memory is problematic because it is surprisingly hard to ensure that we free memory at the right time. Either we forget to free the memory—in which case we have a memory leak—or we free the memory when there are still pointers referring to that memory—in which case we have a pointer that refers to memory that is no longer valid. To make using dynamic memory easier (and safer), the new library provides two smart pointer types that manage dynamic objects. A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points. The new library defines two kinds of smart pointers that differ in how they manage their underlying pointers: shared_ptr, which allows multiple pointers to refer to the same object, and unique_ptr, which “owns” the object to which it points. The library also defines a companion class named weak_ptr that is a weak reference to an object managed by a shared_ptr. All three are defined in the memory header. The shared_ptr ClassLike vectors, smart pointers are templates. Therefore, when we create a smart pointer, we must supply additional information—in this case, the type to which the pointer can point. As with vector, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining: // shared_ptr that can point at a string shared_ptr&lt;string&gt; s_ptr1; // shared_ptr that can point at a vector of int shared_ptr&lt;vector&lt;int&gt;&gt; s_ptr2; A default initialized smart pointer holds a null pointer. We use a smart pointer in ways that are similar to using a pointer. Dereferencing a smart pointer returns the object to which the pointer points. When we use a smart pointer in a condition, the effect is to test whether the pointer is null: // if p1 is not null, check whether it&#39;s the empty string if (s_ptr1 &amp;&amp; s_ptr1-&gt;empty()) &#123; // if so, dereference p1 to assign a new value to that string *s_ptr1 = &quot;hello&quot;; &#125; Next table lists operations common to shared_ptr and unique_ptr. member definition shared_ptr ptr Null smart pointer unique_ptr ptr Null smart pointer ptr as a condition check if ptr point to an object *ptr dereference ptr get object ptr-&gt;member equal to (*ptr).member ptr.get() Returns the stored pointer. swap(ptr1,ptr2) swap pointer ptr1 and ptr2 ptr1.swap(ptr2) swap pointer ptr1 and ptr2 This table show the particular operation for shared_ptr: member definition make_shared(args) Allocates and constructs an object of type T passing args to its constructor. shared_ptr ptr(q) p is a copy of shared_ptr q p=q assign to p p.unique() Check if unique p.use_count() Returns the number of shared_ptr objects that share The safest way to allocate and use dynamic memory is to call a library function named make_shared. This function allocates and initializes an object in dynamic memory and returns a shared_ptr that points to that object. Like the smart pointers, make_shared is defined in the memory header. When we call make_shared, we must specify the type of object we want to create. We do so in the same way as we use a template class, by following the function name with a type enclosed in angle brackets: // shared_ptr that points to an int with value 42 auto ptr1 = make_shared&lt;int&gt;(10); // shared_ptr that points to a string with value HHHHH auto ptr2 = make_shared&lt;string&gt;(5, &#39;H&#39;); // shared_ptr that points to a string with value HELLO shared_ptr&lt;string&gt; ptr3 = make_shared&lt;string&gt;(&quot;HELLO&quot;); // output: 10 HHHHH HELLO cout &lt;&lt; *ptr1 &lt;&lt; &quot; &quot; &lt;&lt; *ptr2 &lt;&lt; &quot; &quot; &lt;&lt; *ptr3 &lt;&lt; endl; Like the sequential-container emplace members, make_shared uses its arguments to construct an object of the given type. Of course, ordinarily we use auto to make it easier to define an object to hold the result of make_shared: When we copy or assign a shared_ptr, each shared_ptr keeps track of how many other shared_ptrs point to the same object: // copy shared_ptr // ptr3 and ptr4 point to the same object // object to which ptr3 and ptr4 point has two users auto ptr4 = ptr3; We can think of a shared_ptr as if it has an associated counter, usually referred to as a reference count. Whenever we copy a shared_ptr, the count is incremented. The counter is decremented when we assign a new value to the shared_ptr and when the shared_ptr itself is destroyed, such as when a local shared_ptr goes out of scope. Once a shared_ptr’s counter goes to zero, the shared_ptr automatically frees the object that it manages: auto r = make_shared&lt;int&gt;(42); // int to which r points has one user r = q; // assign to r, making it point to a different address // increase the use count for the object to which q points // reduce the use count of the object to which r had pointed // the object r had pointed to has no users; that object is automatically freed When the last shared_ptr pointing to an object is destroyed, the shared_ptr class automatically destroys the object to which that shared_ptr points. It does so through another special member function known as a destructor. Analogous to its constructors, each class has a destructor. Just as a constructor controls initialization, the destructor controls what happens when objects of that class type are destroyed. The destructor for shared_ptr decrements the reference count of the object to which that shared_ptr points. If the count goes to zero, the shared_ptr destructor destroys the object to which the shared_ptr points and frees the memory used by that object. The fact that the shared_ptr class automatically frees dynamic objects when they are no longer needed makes it fairly easy to use dynamic memory. For example, we might have a function that returns a shared_ptr to a dynamically allocated object of a type named Foo that can be initialized by an argument of type T:(note this is just a abstract example, this code can not run in computer now) // factory returns a shared_ptr pointing to a dynamically allocated object shared_ptr&lt;Foo&gt; factory(T arg)&#123; // process arg as appropriate // shared_ptr will take care of deleting this memory return make_shared&lt;Foo&gt;(arg); &#125; Because factory returns a shared_ptr, we can be sure that the object allocated by factory will be freed when appropriate. For example, the following function stores the shared_ptr returned by factory in a local variable: void use_factory(T arg)&#123; shared_ptr&lt;Foo&gt; p = factory(arg); // use p &#125; // p goes out of scope; the memory to which p points is automatically freed This is simple case that show the shared_ptr and a refeence: shared_ptr&lt;string&gt; getS() &#123; auto s = make_shared&lt;string&gt;(&quot;hello&quot;); return s; &#125; string&amp; getS(char a) &#123; string s(10, a); return s; &#125; int main()&#123; // ok output hello auto s1 = getS(); cout &lt;&lt; *s1 &lt;&lt; endl; // Segmentation fault auto s2 = getS(&#39;A&#39;); return 0; &#125; Programs tend to use dynamic memory for one of three purposes: They don’t know how many objects they’ll need They don’t know the precise type of the objects they need They want to share data between several objects The container classes are an example of classes that use dynamic memory for the first purpose. In this section, we’ll define a class that uses dynamic memory in order to let several objects share the same underlying data. So far, the classes we’ve used allocate resources that exist only as long as the corresponding objects. For example, each vector “owns” its own elements. When we copy a vector, the elements in the original vector and in the copy are separate from one another: vector&lt;string&gt; v1; // empty vector &#123; // new scope vector&lt;string&gt; v2 = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; v1 = v2; // copies the elements from v2 into v1 &#125; // v2 is destroyed, which destroys the elements in v2 // v1 has three elements, which are copies of the ones originally in v2 Some classes allocate resources with a lifetime that is independent of the original object. As an example, assume we want to define a class named Blob that will hold a collection of elements. Unlike the containers, we want Blob objects that are copies of one another to share the same elements. That is, when we copy a Blob, the original and the copy should refer to the same underlying elements. like this: Blob&lt;string&gt; b1; // empty Blob &#123; // new scope Blob&lt;string&gt; b2 = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; b1 = b2; // b1 and b2 share the same elements &#125; // b2 is destroyed, but the elements in b2 must not be destroyed // b1 points to the elements originally created in b2 Ultimately, we’ll implement our Blob class as a template, but we won’t learn how to do. For now, we’ll define a version of our class that can manage strings. As a result, we’ll name this version of our class StrBlob. The easiest way to implement a new collection type is to use one of the library containers to manage the elements. That way, we can let the library type manage the storage for the elements themselves. In this case, we’ll use a vector to hold our elements. To implement the sharing we want, we’ll give each StrBlob a shared_ptr to a dynamically allocated vector. That shared_ptr member will keep track of how many StrBlobs share the same vector and will delete the vector when the last StrBlob using that vector is destroyed. We still need to decide what operations our class will provide. For now, we’ll implement a small subset of the vector operations. We’ll also change the operations that access elements (e.g., front and back): In our class, these operations will throw an exception if a user attempts to access an element that doesn’t exist. Our class will have a default constructor and a constructor that has a parameter of type initializer_list&lt;string&gt;. This constructor will take a braced list of initializers. This is StrBlob class: #ifndef StrBlob1 #define StrBlob1 #include&lt;memory&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;initializer_list&gt; #include&lt;stdexcept&gt; class StrBlob &#123; public: typedef std::vector&lt;std::string&gt;::size_type size_type; StrBlob() : data(std::make_shared&lt;std::vector&lt;std::string&gt;&gt;()) &#123; &#125;; StrBlob(std::initializer_list&lt;std::string&gt; il) : data(std::make_shared&lt;std::vector&lt;std::string&gt;&gt;(il)) &#123; &#125;; size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; // add and remove elements void push_back(const std::string&amp; t) &#123; data-&gt;push_back(t); &#125; void pop_back(); // element access std::string&amp; front(); std::string&amp; back(); private: // a shared_ptr ponint to string of vector std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data; void check(size_type i, const std::string&amp; msg) const; &#125;; void StrBlob::pop_back() &#123; data-&gt;pop_back(); &#125; std::string&amp; StrBlob::front() &#123; // TODO: insert return statement here return data-&gt;front(); &#125; std::string&amp; StrBlob::back() &#123; // TODO: insert return statement here return data-&gt;back(); &#125; void StrBlob::check(size_type i, const std::string&amp; msg) const &#123; if (i &gt; data-&gt;size()) &#123; throw std::out_of_range(msg); &#125; &#125; #endif // !StrBlob This is test code: StrBlob b1; &#123; StrBlob b2 = &#123; &quot;a&quot;, &quot;an&quot;, &quot;the&quot; &#125;; b1 = b2; b2.push_back(&quot;about&quot;); &#125; cout &lt;&lt; b1.back() &lt;&lt; endl; // output about Managing Memory DirectlyThe language itself defines two operators that allocate and free dynamic memory. The new operator allocates memory, and delete frees memory allocated by new. Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. Instead, new returns a pointer to the object it allocates: int *pi = new int; // pi points to a dynamically allocated, // unnamed, uninitialized int This new expression constructs an object of type int on the free store and returns a pointer to that object. By default, dynamically allocated objects are default initialized, which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor: string *ps = new string; // initialized to empty string int *pi = new int; // pi points to an uninitialized int We can initialize a dynamically allocated object using direct initialization. We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces): int *pi = new int(1024); // object to which pi points has value 1024 string *ps = new string(10, &#39;9&#39;); // *ps is &quot;9999999999&quot; // vector with ten elements with values from 0 to 9 vector&lt;int&gt; *pv = new vector&lt;int&gt;&#123;0,1,2,3,4,5,6,7,8,9&#125;; When we provide an initializer inside parentheses, we can use auto to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer’s type to deduce the type to allocate, we can use auto only with a single initializer inside parentheses: auto p1 = new auto(obj); // p points to an object of the type of obj // that object is initialized from obj auto p2 = new auto&#123;a,b,c&#125;; // error: must use parentheses for the initializer The type of p1 is a pointer to the auto-deduced type of obj. If obj is an int, then p1 is int*; if obj is a string, then p1 is a string*; and so on. The newly allocated object is initialized from the value of obj. Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. Once a program has used all of its available memory, new expressions will fail. By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc. We can prevent new from throwing an exception by using a different form of new: // if allocation fails, new returns a null pointer int *p1 = new int; // if allocation fails, new throws std::bad_alloc int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a delete expression. A delete expression takes a pointer to the object we want to free: delete p1; We need notice the pointer we pass to delete must either point to dynamically allocated memory or be a null pointer. Deleting a pointer to memory that was not allocated by new, or deleting the same pointer value more than once, is undefined: auto* p1 = new int(1); int num = 10; int* p2 = &amp;num; delete p1; //ok delete p2; //error When we delete a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the delete, the pointer becomes what is referred to as a dangling pointer. A dangling pointer is one that refers to memory that once held an object but no longer does so. Dangling pointers have all the problems of uninitialized pointers. We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. Doing so makes it clear that the pointer points to no object. Using shared_ptrs with newAs we’ve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. As described in next table, we can also initialize a smart pointer from a pointer returned by new: member means shared_ptr p(q) p manages the object to which the built-in pointer q points; q must point to memory allocated by new and must be convertible to T*. shared_ptr p(u) p assumes ownership from the unique_ptr u; makes u null. shared_ptr p(q, d) p assumes ownership for the object to which the built-in pointer q points. q must be convertible to T*. p will use the callable object d in place of delete to free q. shared_ptr p(p2, d) p is a copy of the shared_ptr p2 as described in previous Table , except that p uses the callable object d in place of delete. p.reset() If p is the only shared_ptr pointing at its object, reset frees p’s existing object. p.reset(q) If the optional built-in pointer q is passed makes p point to q, otherwise makes p null. p.reset(q, d) If d is supplied, will call d to free q otherwise uses delete to free q. shared_ptr&lt;double&gt; p1; // shared_ptr that can point at a double shared_ptr&lt;int&gt; p2(new int(42)); // p2 points to an int with value 42 The smart pointer constructors that take pointers are explicit. Hence, we cannot implicitly convert a built-in pointer to a smart pointer; we must use the direct form of initialization to initialize a smart pointer: shared_ptr&lt;int&gt; p1 = new int(1024); // error: must use direct initialization shared_ptr&lt;int&gt; p2(new int(1024)); // ok: uses direct initialization By default, a pointer used to initialize a smart pointer must point to dynamic memory because, by default, smart pointers use delete to free the associated object. We can bind smart pointers to pointers to other kinds of resources. However, to do so, we must supply our own operation to use in place of delete. A shared_ptr can coordinate destruction only with other shared_ptrs that are copies of itself. Indeed, this fact is one of the reasons we recommend using make_shared rather than new. That way, we bind a shared_ptr to the object at the same time that we allocate it. There is no way to inadvertently bind the same memory to more than one independently created shared_ptr. Consider the following function that operates on a shared_ptr: // ptr is created and initialized when process is called void process(shared_ptr&lt;int&gt; ptr) &#123; // use ptr &#125; // ptr goes out of scope and is destroyed The parameter to process is passed by value, so the argument to process is copied into ptr. Copying a shared_ptr increments its reference count. Thus, inside process the count is at least 2. When process completes, the reference count of ptr is decremented but cannot go to zero. Therefore, when the local variable ptr is destroyed, the memory to which ptr points will not be deleted. The smart pointer types define a function named get that returns a built-in pointer to the object that the smart pointer is managing. This function is intended for cases when we need to pass a built-in pointer to code that can’t use a smart pointer. The code that uses the return from get must not delete that pointer. shared_ptr&lt;int&gt; p2(new int(10)); auto* p3 = p2.get(); &#123; // undefined: two independent shared_ptrs point to the same memory shared_ptr&lt;int&gt; p4(p3); &#125; // block ends, p4 is destroyed, and the memory to which q points is freed cout &lt;&lt; *p2 &lt;&lt; endl; // undefined; the memory to which p2 points was freed In this case, both p2 and p4 point to the same memory. Because they were created independently from each other, each has a reference count of 1. When the block in which q was defined ends, q is destroyed. Destroying q frees the memory to which q points. That makes p into a dangling pointer, meaning that what happens when we attempt to use p is undefined. Moreover, when p is destroyed, the pointer to that memory will be deleted a second time. The shared_ptr class gives us a few other operations, which are listed in previous table. We can use reset to assign a new pointer to a shared_ptr: p = new int(1024); // error: cannot assign a pointer to a shared_ptr p.reset(new int(1024)); // ok: p points to a new object Like assignment, reset updates the reference counts and, if appropriate, deletes the object to which p points. The reset member is often used together with unique to control changes to the object shared among several shared_ptrs. Before changing the underlying object, we check whether we’re the only user. If not, we make a new copy before making the change: if (!p.unique()) p.reset(new string(*p)); // we aren&#39;t alone; allocate a new copy *p += newVal; // now that we know we&#39;re the only pointer, okay to change this object Smart Pointers and ExceptionsIn previous chapter we noted that programs that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed if an exception occurs. One easy way to make sure resources are freed is to use smart pointers. When we use a smart pointer, the smart pointer class ensures that memory is freed when it is no longer needed even if the block is exited prematurely: void f()&#123; shared_ptr&lt;int&gt; sp(new int(42)); // allocate a new object // code that throws an exception that is not caught inside f &#125; // shared_ptr freed automatically when the function ends When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. In this case, sp is a shared_ptr, so destroying sp checks its reference count. Here, sp is the only pointer to the memory it manages; that memory will be freed as part of destroying sp. In contrast, memory that we manage directly is not automatically freed when an exception occurs. If we use built-in pointers to manage memory and an exception occurs after a new but before the corresponding delete, then that memory won’t be freed: Many C++ classes, including all the library classes, define destructors that take care of cleaning up the resources used by that object. However, not all classes are so well behaved. In particular, classes that are designed to be used by both C and C++ generally require the user to specifically free any resources that are used. unique_ptrA unique_ptr “owns” the object to which it points. Unlike shared_ptr, only one unique_ptr at a time can point to a given object. The object to which a unique_ptr points is destroyed when the unique_ptr is destroyed. Next table lists the operations specific to unique_ptrs. unique_ptr u1 Null unique_ptrs that can point to objects of type T. unique_ptr&lt;T, D&gt; u2 u1 will use delete to free its pointer; u2 will use a callable object of type D to free its pointer. unique_ptr&lt;T, D&gt; u(d) Null unique_ptr that point to objects of type T that uses d, which must be an object of type D in place of delete. u=nullptr Deletes the object to which u points; makes u null. u.release() Relinquishes control of the pointer u had held, returns the pointer u had held and makes u null. u.reset() Deletes the object to which u points u.reset(p) If the built-in pointer q is supplied,makes u point to that object. u.reset(nullptr) Otherwise makes u null. Unlike shared_ptr, there is no library function comparable to make_shared that returns a unique_ptr. Instead, when we define a unique_ptr, we bind it to a pointer returned by new. As with shared_ptrs, we must use the direct form of initialization: unique_ptr&lt;double&gt; p1; // unique_ptr that can point at a double unique_ptr&lt;int&gt; p2(new int(42)); // p2 points to int with value 42 Because a unique_ptr owns the object to which it points, unique_ptr does not support ordinary copy or assignment. Although we can’t copy or assign a unique_ptr, we can transfer ownership from one (nonconst) unique_ptr to another by calling release or reset: // transfers ownership from p1 (which points to the string Stegosaurus) to p2 unique_ptr&lt;string&gt; p2(p1.release()); // release makes p1 null unique_ptr&lt;string&gt; p3(new string(&quot;Trex&quot;)); // transfers ownership from p3 to p2 p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed There is one exception to the rule that we cannot copy a unique_ptr: We can copy or assign a unique_ptr that is about to be destroyed. The most common example is when we return a unique_ptr from a function: unique_ptr&lt;int&gt; clone(int p) &#123; // ok: explicitly create a unique_ptr&lt;int&gt; from int* return unique_ptr&lt;int&gt;(new int(p)); &#125; weak_ptrA weak_ptr is a smart pointer that does not control the lifetime of the object to which it points. Instead, a weak_ptr points to an object that is managed by a shared_ptr. Binding a weak_ptr to a shared_ptr does not change the reference count of that shared_ptr. Once the last shared_ptr pointing to the object goes away, the object itself will be deleted. That object will be deleted even if there are weak_ptrs pointing to it—hence the name weak_ptr, which captures the idea that a weak_ptr shares its object “weakly.” Dynamic ArraysThe new and delete operators allocate objects one at a time. Some applications, need the ability to allocate storage for many objects at once. For example, vectors and strings store their elements in contiguous memory and must allocate several elements at once whenever the container has to be reallocated. To support such usage, the language and library provide two ways to allocate an array of objects at once. The language defines a second kind of new expression that allocates and initializes an array of objects. The library includes a template class named allocator that lets us separate allocation from initialization. Using an allocator generally provides better performance and more flexible memory management. new and ArraysWe ask new to allocate an array of objects by specifying the number of objects to allocate in a pair of square brackets after a type name. In this case, new allocates the requested number of objects and (assuming the allocation succeeds) returns a pointer to the first one: // call get_size to determine how many ints to allocate int *pia = new int[get_size()]; // pia points to the first of these ints The size inside the brackets must have integral type but need not be a constant. We can also allocate an array by using a type alias to represent an array type. In this case, we omit the brackets: using ten_arr = int[10]; int* p2 = new ten_arr; Although it is common to refer to memory allocated by new ten_arr[] as a “dynamic array,” this usage is somewhat misleading. When we use new to allocate an array, we do not get an object with an array type. Instead, we get a pointer to the element type of the array. Even if we use a type alias to define an array type, new does not allocate an object of array type. Because the allocated memory does not have an array type, we cannot call begin or end on a dynamic array. By default, objects allocated by new—whether allocated as a single object or in an array—are default initialized. We can value initialize the elements in an array by following the size with an empty pair of parentheses. int* pia = new int[10]; // block of ten uninitialized ints int* pia2 = new int[10](); // block of ten ints value initialized to 0 string* psa = new string[10]; // block of ten empty strings string* psa2 = new string[10](); // block of ten empty strings Under the new standard, we can also provide a braced list of element initializers: int* pia = new int[10]&#123; 1,2,3,4,5,6,7,8,9,0 &#125;; string* psa = new string[10]&#123; &quot;nvifd&quot;,string(10,&#39;A&#39;) &#125;; To free a dynamic array, we use a special form of delete that includes an empty pair of square brackets: delete p; // p must point to a dynamically allocated object or be null delete [] pa; // pa must point to a dynamically allocated array or be null The second statement destroys the elements in the array to which pa points and frees the corresponding memory. Elements in an array are destroyed in reverse order. That is, the last element is destroyed first, then the second to last, and so on. The library provides a version of unique_ptr that can manage arrays allocated by new. To use a unique_ptr to manage a dynamic array, we must include a pair of empty brackets after the object type: // up points to an array of ten uninitialized ints unique_ptr&lt;int[]&gt; up(new int[10]); up.release(); // automatically uses delete[] to destroy its pointer unqiue_ptrs that point to arrays provide slightly different operations than those we used in previous, we can use the subscript operator to access the elements in the array: for (size_t i = 0; i &lt; 10; i++) &#123; up[i] = i; &#125; Unlike unique_ptr, shared_ptrs provide no direct support for managing a dynamic array. If we want to use a shared_ptr to manage a dynamic array, we must provide our own deleter: // to use a shared_ptr we must supply a deleter shared_ptr&lt;int&gt; sp(new int[10], [](int *p) &#123; delete[] p; &#125;); sp.reset(); // uses the lambda we supplied that uses delete[] to free the array The fact that shared_ptr does not directly support managing arrays affects how we access the elements in the array: for (size_t i = 0; i &lt; 10; i++) &#123; *(sp.get() + i) = i; &#125; The allocator ClassAn aspect of new that limits its flexibility is that new combines allocating memory with constructing object(s) in that memory. Similarly, delete combines destruction with deallocation. Combining initialization with allocation is usually what we want when we allocate a single object. In that case, we almost certainly know the value the object should have. When we allocate a block of memory, we often plan to construct objects in that memory as needed. In this case, we’d like to decouple memory allocation from object construction. Decoupling construction from allocation means that we can allocate memory in large chunks and pay the overhead of constructing the objects only when we actually need to create them. The library allocator class, which is defined in the memory header, lets us separate allocation from construction. It provides type-aware allocation of raw, unconstructed, memory. Next table outlines the operations that allocator supports. In this section, we’ll describe the allocator operations. methods means allocator a Defines an allocator object named a that can allocate memory for objects of type T. a.allocate(n) Allocates raw, unconstructed memory to hold n objects of type T. a.deallocate(p, n) Deallocates memory that held n objects of type T starting at the address in the T* pointer p. a.construct(p, args) which is used to construct an object in the memory pointed to by p a.destory(p) Runs the destructor on the object pointed to by the T*pointer p. Like vector, allocator is a template. To define an allocator we must specify the type of objects that a particular allocator can allocate. When an allocator object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type: allocator&lt;string&gt; alloc; // object that can allocate strings auto const p = alloc.allocate(n); // allocate n unconstructed strings The memory an allocator allocates is unconstructed. We use this memory by constructing objects in that memory. In the new library the construct member takes a pointer and zero or more additional arguments: auto q = p; // q will point to one past the last constructed element alloc.construct(q++); // *q is the empty string alloc.construct(q++, 10, &#39;c&#39;); // *q is cccccccccc alloc.construct(q++, &quot;hi&quot;); // *q is hi! It is an error to use raw memory in which an object has not been constructed: cout &lt;&lt; *q &lt;&lt; endl; // disaster: q points to unconstructed memory! When we’re finished using the objects, we must destroy the elements we constructed, which we do by calling destroy on each constructed element. The destroy function takes a pointer and runs the destructor on the pointed-to object: while (q != p) alloc.destroy(--q); // free the strings we actually allocated Once the elements have been destroyed, we can either reuse the memory to hold other strings or return the memory to the system. We free the memory by calling deallocate: alloc.deallocate(p, n); The pointer we pass to deallocate cannot be null; it must point to memory allocated by allocate. Moreover, the size argument passed to deallocate must be the same size as used in the call to allocate that obtained the memory to which the pointer points. As a companion to the allocator class, the library also defines two algorithms that can construct objects in uninitialized memory. methods means uninitialized_copy Copy block of memory uninitialized_copy_n Copy block of memory uninitialized_fill Fill block of memory uninitialized_fill_n Fill block of memory As an example, assume we have a vector of ints that we want to copy into dynamic memory. We’ll allocate memory for twice as many ints as are in the vector. We’ll construct the first half of the newly allocated memory by copying elements from the original vector. We’ll construct elements in the second half by filling them with a given value: int main() &#123; vector&lt;int&gt; v(2, 2); allocator&lt;int&gt; alloc; auto p = alloc.allocate(v.size() * 2); auto q = uninitialized_copy(v.begin(), v.end(), p); uninitialized_fill_n(q, v.size(), 20); for (size_t i = 0; i &lt; v.size() * 2; i++) &#123; cout &lt;&lt; p[i] &lt;&lt; endl; &#125; return 0; &#125; //output //2 //2 //20 //20 Using the Library: A Text-Query ProgramTo conclude our discussion of the library, we’ll implement a simple text-query program. Our program will let a user search a given file for words that might occur in it. The result of a query will be the number of times the word occurs and a list of lines on which that word appears. Design of the Query Program#pragma once #include&lt;fstream&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;set&gt; #include&lt;memory&gt; #include&lt;map&gt; #include&lt;sstream&gt; #include&lt;iostream&gt; // when we write more than one class in a FILE: // we need protected that first declaration class // then implement method by declaration sequential class QueryResult; class TextQuery &#123; public: using line_no = std::vector&lt;std::string&gt;::size_type; TextQuery() = default; TextQuery(std::ifstream&amp; input); QueryResult query(const std::string&amp; s); private: // input file std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file; // map of each word to the set of the lines in which that word appears std::map &lt;std::string, std::shared_ptr&lt;std::set&lt;line_no&gt;&gt;&gt; wm; &#125;; class QueryResult &#123; friend std::ostream&amp; print(std::ostream&amp;, const QueryResult&amp;); public: QueryResult() = default; QueryResult(std::string s, std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; p, std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; f) : s_word(s), lines(p), file(f) &#123; &#125; private: std::string s_word; std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; file; std::shared_ptr&lt;std::set&lt;TextQuery::line_no&gt;&gt; lines; &#125;; // TextQuery member TextQuery::TextQuery(std::ifstream&amp; input) :file(new std::vector&lt;std::string&gt;) &#123; std::string line, text; while (getline(input, line)) &#123; //read a line and save to vector string file-&gt;push_back(line); //get current line_no size_t n = file-&gt;size() - 1; //save one word where appeared std::istringstream ss(line); while (ss &gt;&gt; text) &#123; // if word isn&#39;t already in wm, subscripting adds a new entry auto&amp; lines = wm[text]; if (!lines) &#123; lines.reset(new std::set&lt;line_no&gt;); &#125; // insert this line number lines-&gt;insert(n); &#125; &#125; &#125; QueryResult TextQuery::query(const std::string&amp; s) &#123; // we&#39;ll return a pointer to this set if we don&#39;t find s static std::shared_ptr&lt;std::set&lt;line_no&gt;&gt; nodata(new std::set&lt;line_no&gt;); auto location = wm.find(s); if (location != wm.end()) &#123; return QueryResult(s, location-&gt;second, file); &#125; else &#123; return QueryResult(s, nodata, file); &#125; &#125; // QueryResult member std::ostream&amp; print(std::ostream&amp; out, const QueryResult&amp; qr) &#123; // TODO: insert return statement here out &lt;&lt; qr.s_word &lt;&lt; &quot; appear &quot; &lt;&lt; (qr.lines)-&gt;size() &lt;&lt; &quot; times:&quot; &lt;&lt; std::endl; for (auto&amp; line : *(qr.lines)) &#123; out &lt;&lt; line + 1 &lt;&lt; &quot;: &quot; &lt;&lt; (qr.file)-&gt;at(line) &lt;&lt; std::endl; &#125; return out; &#125; Main program#include&lt;fstream&gt; #include&lt;iostream&gt; #include &quot;ch12_3.h&quot; using namespace std; int main() &#123; ifstream input(&quot;text.txt&quot;); TextQuery tq(input); string s; while (true) &#123; cout &lt;&lt; &quot;input a word you want query:&quot; &lt;&lt; endl; if (!(cin &gt;&gt; s) || s == &quot;q&quot;) &#123; break; &#125; auto qr = tq.query(s); print(std::cout, qr); &#125; return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch7) Associative Containers","slug":"c++ c7","date":"2021-12-24T13:52:45.000Z","updated":"2023-04-21T08:45:04.021Z","comments":true,"path":"2021/12/24/c++ c7/","link":"","permalink":"https://noahbishop.github.io/2021/12/24/c++%20c7/","excerpt":"","text":"Associative ContainersAssociative and sequential containers differ from one another in a fundamental way: Elements in an associative container are stored and retrieved by a key. In contrast, elements in a sequential container are stored and accessed sequentially by their position in the container. Associative containers support efficient lookup and retrieval by a key. The two primary associative-container types are map and set. The elements in a map are key–value pairs: The key serves as an index into the map, and the value represents the data associated with that index. A set element contains only a key; a set supports efficient queries as to whether a given key is present. We might use a set to hold words that we want to ignore during some kind of text processing. A dictionary would be a good use for a map: The word would be the key, and its definition would be the value. The library provides eight associative containers, listed in next table. These eight differ along three dimensions: Each container is (1) a set or a map, (2) requires unique keys or allows multiple keys, and (3) stores the elements in order or not. Type definition map Associated array; Key-value pairs set unique key; multimap key can appear multiple times multiset key can appear multiple times unordered_map hash ~ unordered_set hash ~ unordered_multimap hash ~ unordered_multiset hash ~ Using an Associative ContainerUsing a mapA classic example that relies on associative arrays is a word-counting program, this program reads its input and reports how often each word appears. //read word from istream, when word is EOF end read int read_word(istream&amp; in, string&amp; word) &#123; in &gt;&gt; word; if (word == (&quot;EOF&quot;)) &#123; return 0; &#125; return 1; &#125; int main() &#123; // count the number of times each word occurs in the input map&lt;string, size_t&gt; count_words; string word; while (read_word(cin, word)) &#123; ++count_words[word]; &#125; //in vs2019 type rfor can autofill for range for (const auto&amp; w : count_words) &#123; cout &lt;&lt; w.first &lt;&lt; &quot; appear &quot; &lt;&lt; w.second &lt;&lt; &quot; times.&quot; &lt;&lt; endl; &#125; return 0; &#125; //C++ //java //C++ //c# //EOF //C++ appear 2 times. //c# appear 1 times. //java appear 1 times. Like the sequential containers, the associative containers are templates. To define a map, we must specify both the key and value types. In this program, the map stores elements in which the keys are string and the values are size_t. When we subscript word_count, we use a string as the subscript, and we get back the size_t counter associated with that string. Using a setAs a example, suppose some words we want exclude when count word, we can use a set to save the words need to exclude. //SAME------ //save exclude word while (read_word(cin, word)) &#123; exclude.insert(word); &#125; //count word while (read_word(cin, word)) &#123; if (exclude.find(word) == exclude.end()) ++count_words[word]; &#125; //SAME------ Like the other containers, set is a template. To define a set, we specify the type of its elements, which in this case are string. Overview of the Associative ContainersAssociative containers (both ordered and unordered) support the general container operations covered in previous chapter table. However, the associative containers do not support the sequential-container position-specific operations, such as push_front or back. Defining an Associative ContainerAs we’ve just seen, when we define a map, we must indicate both the key and value type; when we define a set, we specify only a key type, because there is no value type. Each of the associative containers defines a default constructor, which creates an empty container of the specified type. We can also initialize an associative container as a copy of another container of the same type or from a range of values, so long as those values can be converted to the type of the container. Under the new standard, we can also list initialize the elements: map&lt;string, size_t&gt; count_words = &#123; &#123;&quot;hello&quot;,3&#125; &#125;; set&lt;string&gt; exclude = &#123; &quot;c++&quot;,&quot;Java&quot; &#125;; The keys in a map or a set must be unique; there can be only one element with a given key. The multimap and multiset containers have no such restriction; there can be several elements with the same key. For example, the map we used to count words must have only one element per given word. On the other hand, a dictionary could have several definitions associated with a particular word. // define a vector with 20 elements, holding two copies of each number from 0 to 9 vector&lt;int&gt; ivec; for (vector&lt;int&gt;::size_type i = 0; i != 10; ++i) &#123; ivec.push_back(i); ivec.push_back(i); // duplicate copies of each number &#125; // iset holds unique elements from ivec; miset holds all 20 elements set&lt;int&gt; iset(ivec.cbegin(), ivec.cend()); multiset&lt;int&gt; miset(ivec.cbegin(), ivec.cend()); cout &lt;&lt; ivec.size() &lt;&lt; endl; // prints 20 cout &lt;&lt; iset.size() &lt;&lt; endl; // prints 10 cout &lt;&lt; miset.size() &lt;&lt; endl; // prints 20 Requirements on Key TypeThe associative containers place constraints on the type that is used as a key. We’ll cover the requirements for keys in the unordered containers in section 4. For the ordered containers, the key type must define a way to compare the elements. By default, the library uses the &lt; operator for the key type to compare the keys. In the set types, the key is the element type; in the map types, the key is the first type. The pair TypeBefore we look at the operations on associative containers, we need to know about the library type named pair, which is defined in the utility header. A pair holds two data members. Like the containers, pair is a template from which we generate specific types. We must supply two type names when we create a pair. The data members of the pair have the corresponding types. There is no requirement that the two types be the same: pair&lt;string, string&gt; anon; // holds two strings pair&lt;string, size_t&gt; word_count; // holds a string and an size_t pair&lt;string, vector&lt;int&gt;&gt; line; // holds string and vector&lt;int&gt; We can also provide initializers for each member: pair&lt;string, string&gt; author&#123;&quot;James&quot;, &quot;Joyce&quot;&#125;; Unlike other library types, the data members of pair are public. These members are named first and second, respectively. cout &lt;&lt;author.first&lt;&lt;author.second &lt;&lt; endl; Imagine we have a function that needs to return a pair. Under the new standard we can list initialize the return value: pair&lt;string, int&gt; process(vector&lt;string&gt;&amp; v) &#123; // process v if (!v.empty()) return &#123; v.back(), v.back().size() &#125;; // list initialize else return pair&lt;string, int&gt;(); // explicitly constructed return value &#125; Alternatively, we could have used make_pair to generate a new pair of the appropriate type from its two arguments: return make_pair(v.back(), v.back().size()); Operations on Associative ContainersIn addition to the types listed in previous chapter, the associative containers define the types listed in next list: key_type: type of the key for container tyoe map_type: type associated with each key. value_type: for set same as key_type set&lt;string&gt;::value_type v1; // v1 is a string set&lt;string&gt;::key_type v2; // v2 is a string map&lt;string, int&gt;::value_type v3; // v3 is a pair&lt;const string, int&gt; map&lt;string, int&gt;::key_type v4; // v4 is a string map&lt;string, int&gt;::mapped_type v5; // v5 is an int Associative Container IteratorsWhen we dereference an iterator, we get a reference to a value of the container’s value_type. In the case of map, the value_type is a pair in which first holds the const key and second holds the value: // get an iterator to an element in word_count map&lt;string, size_t&gt; count_words = &#123; &#123;&quot;hello&quot;,3&#125; &#125;; auto map_it = count_words.begin(); // *map_it is a reference to a pair&lt;const string, size_t&gt; object cout &lt;&lt; map_it-&gt;first; // prints the key for this element cout &lt;&lt; &quot; &quot; &lt;&lt; map_it-&gt;second; // prints the value of the element map_it-&gt;first = &quot;new key&quot;; // error: key is const ++map_it-&gt;second; // ok: we can change the value through an iterator Although the set types define both the iterator and const_iterator types, both types of iterators give us read-only access to the elements in the set. Just as we cannot change the key part of a map element, the keys in a set are also const. We can use a set iterator to read, but not write, an element’s value: set&lt;int&gt; iset = &#123;0,1,2,3,4,5,6,7,8,9&#125;; set&lt;int&gt;::iterator set_it = iset.begin(); if (set_it != iset.end()) &#123; *set_it = 42; // error: keys in a set are read-only cout &lt;&lt; *set_it &lt;&lt; endl; // ok: can read the key &#125; In general, we do not use the generic algorithms with the associative containers. The fact that the keys are const means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such algorithms need to write to the elements. The elements in the set types are const, and those in maps are pairs whose first element is const. Associative containers can be used with the algorithms that read elements. However, many of these algorithms search the sequence. Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. Adding ElementsThe insert members add one element or a range of elements. Because map and set (and the corresponding unordered types) contain unique keys, inserting an element that is already present has no effect: vector&lt;string&gt; k = &#123; &quot;ourb&quot;,&quot;uvrgsu&quot;,&quot;ourb&quot; &#125;; auto m = process(k); set&lt;string&gt; s; s.insert(k.begin(), k.end()); s.insert(&#123; &quot;ourb&quot;,&quot;ivgr&quot; &#125;); The versions of insert that take a pair of iterators or an initializer list work similarly to the corresponding constructors—only the first element with a given key is inserted. When we insert into a map, we must remember that the element type is a pair. Often, we don’t have a pair object that we want to insert. Instead, we create a pair in the argument list to insert: // four ways to add word to word_count word_count.insert(&#123;word, 1&#125;); word_count.insert(make_pair(word, 1)); word_count.insert(pair&lt;string, size_t&gt;(word, 1)); word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1)); The value returned by insert (or emplace) depends on the container type and the parameters. For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. The first member of the pair is an iterator to the element with the given key; the second is a bool indicating whether that element was inserted, or was already there. If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. If the key isn’t present, then the element is inserted and the bool is true. while (read(cin,word)) &#123; auto isSuccess = count_words.insert(&#123; word,1 &#125;); if (!isSuccess.second) &#123; ++isSuccess.first-&gt;second; &#125; &#125; For each word, we attempt to insert it with a value 1. If word is already in the map, then nothing happens. In particular, the counter associated with word is unchanged. If word is not already in the map, then that string is added to the map and its counter value is set to 1. Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word. Sometimes, we want to be able to add additional elements with the same key. multimap&lt;string, int&gt; au; au.insert(&#123; &quot;A&quot;,10 &#125;); au.insert(&#123; &quot;A&quot;,20 &#125;); cout &lt;&lt; au.size() &lt;&lt; endl; // 2 Erasing ElementsThe associative containers define three versions of erase, which are described in next table. As with the sequential containers, we can erase one element or a range of elements by passing erase an iterator or an iterator pair. These versions of erase are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns void. version means erase (const_iterator position); erase by a iterator. erase (const key_type&amp; k); erase by a key. erase (first, last) erase by a range of element by a pair of iterator. The version need parameter k removes all the elements, if any, with the given key and returns a count of how many elements were removed. if (word_count.erase(removal_word)) cout &lt;&lt; &quot;ok: &quot; &lt;&lt; removal_word &lt;&lt; &quot; removed\\n&quot;; else cout &lt;&lt; &quot;oops: &quot; &lt;&lt; removal_word &lt;&lt; &quot; not found!\\n&quot;; Subscripting a mapThe map and unordered_map containers provide the subscript operator and a corresponding a~t function. The set types do not support subscripting because there is no “value” associated with a key in a set. The elements are themselves keys, so the operation of “fetching the value associated with a key” is meaningless. We can not subscript a multimap or an unordered_multimap because there may be more than one value associated with a given key. Like the other subscript operators we’ve used, the map subscript takes an index (that is, a key) and fetches the value associated with that key. However, unlike other subscript operators, if the key is not already present, a new element is created and inserted into the map for that key. // a empty map map&lt;string, string&gt; au; // insert a value-initialized element with key a; then assign 10 to its value au[&quot;a&quot;] = &quot;10&quot;; // a invalid kay will return initialize value and save cout &lt;&lt; au[&quot;b&quot;] &lt;&lt; endl; au is searched for the element whose key is a. The element is not found. A new key-value pair is inserted into au. The key is a const string holding Anna. The value is value initialized, meaning in this case that the value is &quot;&quot;. The newly inserted element is fetched and is given the value “10“. The fact that the subscript operator adds an element if it is not already in the map, On the other hand, sometimes we only want to know whether an element is present and do not want to add the element if it is not. Accessing ElementsThe associative containers provide various ways to find a given element, which are described in next table. Which operation to use depends on what problem we are trying to solve. If all we care about is whether a particular element is in the container, it is probably best to use find. For the containers that can hold only unique keys, it probably doesn’t matter whether we use find or count. However, for the containers with multiple keys, count has to do more work: If the element is present, it still has to count how many elements have the same key. If we don’t need the count, it’s best to use find: methods means find Get iterator to element count Count elements with a specific key lower_bound Return iterator to lower bound upper_bound Return iterator to upper bound equal_range Get range of equal elements multiset&lt;int&gt; iset = &#123; 0,1,2,3,4,5,6,7,8,9,1 &#125;; auto fa1 = iset.find(1); //returns an iterator that refers to the element with key = 1 auto fa2 = iset.find(11); // returns the iterator == iset.end() auto fa3 = iset.count(1); // returns 2 auto fa4 = iset.count(11); // returns 0 Finding an element in an associative container that requires unique keys is a simple matter—the element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the given key. When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container. multimap&lt;int, int&gt; ikdn; ikdn.insert(&#123; 1,2 &#125;); ikdn.insert(&#123; 2,5 &#125;); ikdn.insert(&#123; 1,7 &#125;); auto num = ikdn.count(1); auto iter = ikdn.find(1); // a iterator point to a pair while (num) &#123; cout &lt;&lt; iter-&gt;second &lt;&lt; endl; ++iter; --num; &#125; We are guaranteed that iterating across a multimap or multiset returns all the elements with a given key in sequence. Alternatively, we can solve our problem using lower_bound and upper_bound. Each of these operations take a key and returns an iterator. If the key is in the container, the iterator returned from lower_bound will refer to the first instance of that key and the iterator returned by upper_bound will refer just after the last instance of the key. If the element is not in the multimap, then lower_bound and upper_bound will return equal iterators; both will refer to the point at which the key can be inserted without disrupting the order. Thus, calling lower_bound and upper_bound on the same key yields an iterator range that denotes all the elements with that key. multimap&lt;int, int&gt; ikdn; ikdn.insert(&#123; 1,2 &#125;); ikdn.insert(&#123; 2,5 &#125;); ikdn.insert(&#123; 1,7 &#125;); for (auto i = ikdn.lower_bound(1); i != ikdn.upper_bound(1); i++) &#123; cout &lt;&lt; i-&gt;second &lt;&lt; endl; &#125; The remaining way to solve this problem is the most direct of the three approaches: Instead of calling upper_bound and lower_bound, we can call equal_range. This function takes a key and returns a pair of iterators. If the key is present, then the first iterator refers to the first instance of the key and the second iterator refers one past the last instance of the key. for (auto pos = ikdn.equal_range(1); pos.first != pos.second; ++pos.first) &#123; cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; &#125; A Word Transformation Map#include&lt;bits/stdc++.h&gt; using namespace std; void transform(ifstream&amp; in_que, ifstream&amp; in_tran) &#123; map&lt;string, string&gt; dir; //read transform rules string sou, con, text, word; while (in_tran &gt;&gt; sou &gt;&gt; con) &#123; dir[sou] = con; &#125; in_tran.close(); //read question while (getline(in_que, text)) &#123; istringstream ss(text); while (ss &gt;&gt; word) &#123; if (dir.find(word) != dir.end()) &#123; cout &lt;&lt; dir[word] &lt;&lt; &quot; &quot;; &#125; else &#123; cout &lt;&lt; word &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; &#125; &#125; int main() &#123; ifstream in_que(&quot;ques.txt&quot;); ifstream in_tran(&quot;trans.txt&quot;); transform(in_que, in_tran); return 0; &#125; The Unordered ContainersThe new standard defines four unordered associative containers. Rather than using a comparison operation to organize their elements, these containers use a hash function and the key type’s == operator. An unordered container is most useful when we have a key type for which there is no obvious ordering relationship among the elements. These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive. Using an Unordered ContainerAside from operations that manage the hashing, the unordered containers provide the same operations (find, insert, and so on) as the ordered containers. That means that the operations we’ve used on map and set apply to unordered_map and unordered_set as well. Similarly for the unordered versions of the containers that allow multiple keys. As a result, we can usually use an unordered container in place of the corresponding ordered container, and vice versa. However, because the elements are not stored in order, the output of a program that uses an unordered container will (ordinarily) differ from the same program using an ordered container. For example, we can rewrite our original word-counting program to use an unordered_map and compare them; #include&lt;bits/stdc++.h&gt; using namespace std; //uppercase string void upperCase(string&amp; str) &#123; for (auto&amp; i : str) &#123; i = toupper(i); &#125; &#125; //read word from istream, when word is EOF end read int read_word(istream&amp; in, string&amp; word) &#123; in &gt;&gt; word; upperCase(word); if (word == (&quot;EOF&quot;)) &#123; return 0; &#125; return 1; &#125; int main() &#123; // count the number of times each word occurs in the input map&lt;string, size_t&gt; count_words; unordered_map&lt;string, size_t&gt; unorder_count_words; set&lt;string&gt; exclude = &#123; &quot;c++&quot;,&quot;Java&quot; &#125;; string word; while (read_word(cin, word)) &#123; // add to order map auto isSuccess1 = count_words.insert(&#123; word,1 &#125;); if (!isSuccess1.second) &#123; ++isSuccess1.first-&gt;second; &#125; // add to unorder map auto isSuccess2 = unorder_count_words.insert(&#123; word,1 &#125;); if (!isSuccess2.second) &#123; ++isSuccess2.first-&gt;second; &#125; &#125; //order map for (const auto&amp; w : count_words) &#123; cout &lt;&lt; w.first &lt;&lt; &quot; appear &quot; &lt;&lt; w.second &lt;&lt; &quot; times.&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;__________&quot; &lt;&lt; endl; //unorder map for (const auto&amp; w : unorder_count_words) &#123; cout &lt;&lt; w.first &lt;&lt; &quot; appear &quot; &lt;&lt; w.second &lt;&lt; &quot; times.&quot; &lt;&lt; endl; &#125; return 0; &#125; //c //a //b //eof //A appear 1 times. //B appear 1 times. //C appear 1 times. //__________ //B appear 1 times. //C appear 1 times. //A appear 1 times. The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. These containers use a hash function to map elements to buckets. To access an element, the container first computes the element’s hash code, which tells which bucket to search. The container puts all of its elements with a given hash value into the same bucket. If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets. The unordered containers provide a set of functions, in here, that let us manage the buckets. These members let us inquire about the state of the container and force the container to reorganize itself as needed. Requirements on Key Type for Unordered ContainersBy default, the unordered containers use the == operator on the key type to compare elements. They also use an object of type hash&lt;key_type&gt; to generate the hash code for each element. The library supplies versions of the hash template for the built in types, including pointers. It also defines hash for some of the library types, including strings and the smart pointer types that we will describe in next chapter. Thus, we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer. However, we cannot directly define an unordered container that uses a our own class types for its key type. Unlike the containers, we cannot use the hash template directly. Instead, we must supply our own version of the hash template.","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch6) Generic Algorithms","slug":"c++ c6","date":"2021-12-23T13:52:45.000Z","updated":"2023-04-21T08:45:02.190Z","comments":true,"path":"2021/12/23/c++ c6/","link":"","permalink":"https://noahbishop.github.io/2021/12/23/c++%20c6/","excerpt":"","text":"Generic AlgorithmsThe library containers define a surprisingly small set of operations. Rather than adding lots of functionality to each container, the library provides a set of algorithms, most of which are independent of any particular container type. These algorithms are generic: They operate on different types of containers and on elements of various types. OverviewMost of the algorithms are defined in the algorithm header. The library also defines a set of generic numeric algorithms that are defined in the numeric header. In general, the algorithms do not work directly on a container. Instead, they operate by traversing a range of elements bounded by two iterators. If we want find a substring in string container, we can use the s.find function, however the vector does not provide method find, how could we do? The generic algorithm provides a function called find can do this: int main() &#123; vector&lt;int&gt; k = &#123; 5,4,3,2,1 &#125;; // result will denote the element we want if it&#39;s in vec, or vec.cend() if not auto pos1 = find(k.cbegin(), k.cend(), 6); auto pos2 = find(k.cbegin(), k.cend(), 2); cout &lt;&lt; (pos1 == k.cend()) &lt;&lt; &quot; &quot; &lt;&lt; *pos2 &lt;&lt; endl; return 0; &#125; //out put //1 2 The first two arguments to find are iterators denoting a range of elements, and the third argument is a value. find compares each element in the given range to the given value. It returns an iterator to the first element that is equal to that value. If there is no match, find returns its second iterator to indicate failure.(in this case id k.cend()) How the Algorithms WorkConceptually, we can list the steps find must take: It accesses the first element in the sequence. It compares that element to the value we want. If this element matches the one we want, find returns a value that identifies this element. Otherwise, find advances to the next element and repeats steps 2 and 3. find must stop when it has reached the end of the sequence. If find gets to the end of the sequence, it needs to return a value indicating that the element was not found. This value and the one returned from step 3 must have compatible types. None of these operations depends on the type of the container that holds the elements. Iterators Make the Algorithms Container IndependentAll but the second step in the find function can be handled by iterator operations: The iterator dereference operator gives access to an element’s value; But Algorithms Do Depend on Element-Type OperationsFor example, step 2, uses the element type’s == operator to compare each element to the given value. A First Look at the AlgorithmsThe library provides more than 100 algorithms. Fortunately, like the containers, the algorithms have a consistent architecture. Understanding this architecture makes learning and using the algorithms easier than memorizing all 100+ of them. With only a few exceptions, the algorithms operate over a range of elements. We’ll refer to this range as the “input range”. The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process. Read-Only AlgorithmsA number of the algorithms read, but never write to, the elements in their input range. The find function is one such algorithm, as is the count function which count a value how often. Another read-only algorithm is accumulate, which is defined in the numeric header. The first two parameters specify a range of elements to sum. The third is an initial value for the sum. int main() &#123; vector&lt;int&gt; k = &#123; 5,4,5,2,1 &#125;; // output is 2 cout &lt;&lt; count(k.cbegin(), k.cend(), 5) &lt;&lt; endl; // output is initvalue 2 add all vector equal to 2+17=19 cout &lt;&lt; accumulate(k.cbegin(), k.cend(), 2) &lt;&lt; endl; return 0; &#125; The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns. The fact that accumulate uses its third argument as the starting point for the summation has an important implication: It must be possible to add the element type to the type of the sum. That is, the elements in the sequence must match or be convertible to the type of the third argument. Another read-only algorithm is equal, which lets us determine whether two sequences hold the same values. It compares each element from the first sequence to the corresponding element in the second. It returns true if the corresponding elements are equal, false otherwise. The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence: int main() &#123; vector&lt;int&gt; v1 = &#123; 1,2,3,4,5 &#125;; vector&lt;int&gt; v2 = &#123; 1,2,3,4,5 &#125;; // ouput is 1 cout &lt;&lt; equal(v1.cbegin() - 1, v1.cend(), v2.cbegin() - 1) &lt;&lt; endl; return 0; &#125; Because equal operates in terms of iterators, we can call equal to compare elements in containers of different types. Moreover, the element types also need not be the same so long as we can use == to compare the element types. int main() &#123; vector&lt;string&gt; vs = &#123; &quot;123&quot;,&quot;234&quot; &#125;; list&lt;char*&gt; lc = &#123; &quot;123&quot;,&quot;234&quot; &#125;; // out put is 1 cout &lt;&lt; equal(vs.cbegin(), vs.cend(), lc.cbegin()) &lt;&lt; endl; return 0; &#125; NOTICE: Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first. Algorithms That Write Container ElementsSome algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container operations, so they have no way themselves to change the size of a container. the fill algorithm takes a pair of iterators that denote a range and a third argument that is a value. fill assigns the given value to each element in the input sequence: int main() &#123; vector&lt;string&gt; vs(10); fill(vs.begin(), vs.end(), &quot;A&quot;); return 0; &#125; Some algorithms take an iterator that denotes a separate destination. These algorithms assign new values to the elements of a sequence starting at the element denoted by the destination iterator. For example, the fill_n function takes a single iterator, a count, and a value. It assigns the given value to the specified number of elements starting at the element denoted to by the iterator. int main() &#123; vector&lt;string&gt; vs(10); fill_n(vs.begin(), vs.size(), &quot;A&quot;); return 0; &#125; One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator. An insert iterator is an iterator that adds elements to a container. back_inserter, which is a function defined in the iterator header. back_inserter takes a reference to a container and returns an insert iterator bound to that container. When we assign through that iterator, the assignment calls push_back to add an element with the given value to the container: int main() &#123; vector&lt;string&gt; k; auto it = back_inserter(k); *it = &quot;hello&quot;; cout &lt;&lt; *k.cbegin() &lt;&lt; endl; return 0; &#125; // output // hello We frequently use back_inserter to create an iterator to use as the destination of an algorithm. For example: int main() &#123; vector&lt;string&gt; k; fill_n(back_inserter(k), 5, &quot;A&quot;); for (auto m : k) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; return 0; &#125; // output // AAAAA The copy algorithm is another example of an algorithm that writes to the elements of an output sequence denoted by a destination iterator. This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. The value returned by copy is the (incremented) value of its destination iterator. That is, ret will point just past the last element copied into a2. int main() &#123; int a1[] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int a2[sizeof(a1) / sizeof(*a1)]; // a2 has the same size as a1 // ret points just past the last element copied into a2 auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2 cout &lt;&lt; *(ret - 1) &lt;&lt; endl; // output is 9 return 0; &#125; the replace algorithm reads a sequence and replaces every instance of a given value with another value. This algorithm takes four parameters: two iterators denoting the input range, and two values. It replaces each element that is equal to the first value with the second: int main() &#123; vector&lt;string&gt; k; fill_n(back_inserter(k), 5, &quot;A&quot;); replace(k.begin(), k.end(), &quot;A&quot;, &quot;B&quot;); //output BBBBB for (auto m : k) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; return 0; &#125; If we want to leave the original sequence unchanged, we can call replace_copy. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence: replace_copy(k.begin(), k.end(), back_inserter(m), &quot;A&quot;, &quot;B&quot;); Algorithms That Reorder Container ElementsSome algorithms rearrange the order of elements within a container. An obvious example of such an algorithm is sort. A call to sort arranges the elements in the input range into sorted order using the element type’s &lt; operator. int main() &#123; vector&lt;int&gt; vec = &#123; 5,4,3,4,1,2 &#125;; sort(vec.begin(), vec.end()); return 0; &#125; To eliminate the duplicated words, we will first sort the vector so that duplicated words appear adjacent to each other. Once the vector is sorted, we can use another library algorithm, named unique, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do container operations, we’ll use the erase member of vector to actually remove the elements: void elimDups(vector&lt;int&gt;&amp; vec) &#123; sort(vec.begin(), vec.end()); auto end_unique = unique(vec.begin(), vec.end()); vec.erase(end_unique, vec.end()); &#125; You can see more details about unique in here. Shortly, the removal is done by replacing the duplicate elements by the next element that is not a duplicate, and signaling the new size of the shortened range by returning an iterator to the element that should be considered its new past-the-end element. #include&lt;bits/stdc++.h&gt; using namespace std; void printVec(vector&lt;int&gt;&amp; vec) &#123; for (auto veci : vec) &#123; cout &lt;&lt; veci &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; void elimDups(vector&lt;int&gt;&amp; vec) &#123; // sorted sort(vec.begin(), vec.end()); printVec(vec); // uniqued auto end_unique = unique(vec.begin(), vec.end()); printVec(vec); // remove duplicates vec.erase(end_unique, vec.end()); printVec(vec); &#125; int main() &#123; vector&lt;int&gt; vec = &#123; 5,4,3,4,1,2,1 &#125;; elimDups(vec); return 0; &#125; the end_unique denotes one past the last unique element. Customizing OperationsMany of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type’s &lt; or == operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator. For example, the sort algorithm uses the element type’s &lt; operator. However, we might want to sort a sequence into a different order from that defined by &lt;, or our sequence might have elements of a type (such as Sales_data) that does not have a &lt; operator. In both cases, we need to override the default behavior of sort. Passing a Function to an AlgorithmAs one example, assume that we want to sort string order by length, and then alphabetically within each size. To reorder the vector by length, we’ll use a second, overloaded version of sort. This version of sort takes a third argument that is a predicate. A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters). #include&lt;bits/stdc++.h&gt; using namespace std; bool isShort(const string&amp; str1, const string&amp; str2) &#123; if (str1.size() != str2.size()) &#123; return str1.size() &lt; str2.size(); &#125; else &#123; return str1 &lt; str2; &#125; &#125; int main() &#123; vector&lt;string&gt; vec = &#123; &quot;bbcd&quot;,&quot;abcd&quot;,&quot;c&quot; &#125;; sort(vec.begin(), vec.end(), isShort); for (auto i = vec.begin(); i != vec.end(); i++) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0; &#125; Lambda ExpressionsThe predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respectively. However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows. As a example, if we want find the first element in the string vector that has the given size, we can use the library find_if algorithm to find an element that has a particular size. Like find, the find_if algorithm takes a pair of iterators denoting a range. Unlike find, the third argument to find_if is a predicate. The find_if algorithm calls the given predicate on each element in the input range. It returns the first element for which the predicate returns a nonzero value, or its end iterator if no such element is found. However, find_if takes a unary predicate—any function we pass to find_if must have exactly one parameter that can be called with an element from the input sequence. There is no way to pass a second argument representing the size. We can pass any kind of callable object to an algorithm. The only callables we’ve used so far are functions and function pointers. There are two other kinds of callables: classes that overload the function-calloperator, and lambda expressions. The format of lambda expressions is [capture list] (parameter list) -&gt; return type &#123; function body &#125;. capture list is an (often empty) list of local variables defined in the enclosing function return type, parameter list, and function body are the same as in any ordinary function. We’re now ready to solve our original problem, which is to write a callable expression that we can pass to find_if. We want an expression that will compare the length of each string in the input sequence with the value of the sz parameter in the biggies function. int main() &#123; vector&lt;string&gt; vec = &#123; &quot;bbcd&quot;,&quot;abcd&quot;,&quot;sd&quot;,&quot;c&quot; &#125;; size_t sz = 2; auto wc = find_if(vec.begin(), vec.end(), [sz](const string&amp; str) &#123; return str.size() &lt;= sz; &#125;); cout &lt;&lt; *wc &lt;&lt; endl; // output is sd return 0; &#125; Lambda Captures and ReturnsWhen we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda. For now, what’s useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use auto to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda. Similar to parameter passing, we can capture variables by value or by reference. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called: int v = 10; auto k = [v]() &#123;return v; &#125;; v = 100; cout &lt;&lt; k() &lt;&lt; endl; // output is 10 We can also define lambdas that capture variables by reference. For example: int v = 10; auto k = [v]() &#123;return v; &#125;; v = 100; cout &lt;&lt; k() &lt;&lt; endl; // output is 10 Rather than explicitly listing the variables we want to use from the enclosing function, we can let the compiler infer which variables we use from the code in the lambda’s body. To direct the compiler to infer the capture list, we use an &amp; or = in the capture list. The &amp; tells the compiler to capture by reference, and the = says the values are captured by value. int v = 10; auto k = [=]() &#123;return v; &#125;; v = 100; cout &lt;&lt; k() &lt;&lt; endl; // output is 10 int v = 10; auto k = [&amp;]() &#123;return v; &#125;; v = 100; cout &lt;&lt; k() &lt;&lt; endl; // output is 100 If we want to capture some variables by value and others by reference, we can mix implicit and explicit captures: int v = 10, d = 20; auto k = [=, &amp;d]() &#123;return v + d; &#125;; v = 100; d = 50; cout &lt;&lt; k() &lt;&lt; endl; // output is 60 By default, a lambda may not change the value of a variable that it copies by value. If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword mutable. Lambdas that are mutable may not omit the parameter list: int v = 10; auto k = [v]()mutable &#123;v = 100; return v; &#125;; cout &lt;&lt; k() &lt;&lt; endl; // output is 100 cout &lt;&lt; v &lt;&lt; endl; // output is 10 The lambdas we’ve written so far contain only a single return statement. We can use -&gt; type specify return type. auto k = [=, &amp;d]()-&gt;int &#123;return v + d; &#125;; Binding ArgumentsIt is usually straightforward to use a function in place of a lambda that has an empty capture list. As we’ve seen, we can use either a lambda or our isShort function to order the vector on word length. However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to find_if compared a string with a given size. We can easily write a function to do the same work: bool check_size(const string &amp;s, string::size_type sz)&#123; return s.size() &gt;= sz; &#125; However, we can’t use this function as an argument to find_if. Because find_if takes a unary predicate. The lambda that biggies passed to find_if used its capture list to store sz. In order to use check_size in place of that lambda, we have to figure out how to pass an argument to the sz parameter. We can solve the problem of passing a size argument to check_size by using a new library function named bind, which is defined in the functional header. The bind function can be thought of as a general-purpose function adaptor. It takes a callable object and generates a new callable that “adapts” the parameter list of the original object. The form is auto newCallable = bind(callable, arg_list);. The arguments in arg_list may include names of the form placeholders::_n, where n is an integer. These arguments are “placeholders” representing the parameters of newCallable. They stand “in place of” the arguments that will be passed to newCallable. The number n is the position of the parameter in the generated callable: _1 is the first parameter in newCallable,_2 is the second, and so forth. auto check_new = bind(check_size, placeholders::_1, 2); Using bind, we can replace our original lambda-based call to find_if: auto wc = find_if(vec.begin(), vec.end(), check_new); Revisiting IteratorsIn addition to the iterators that are defined for each of the containers, the library defines several additional kinds of iterators in the iterator header. These iterators include Insert iterators: These iterators are bound to a container and can be used to insert elements into the container. Stream iterators: These iterators are bound to input or output streams and can be used to iterate through the associated IO stream. Reverse iterators: These iterators move backward, rather than forward. The library containers, other than forward_list, have reverse iterators. Move iterators: These special-purpose iterators move rather than copy their elements. Insert IteratorsAn inserter is an iterator adaptor that takes a container and yields an iterator that adds elements to the specified container. There are three kinds of inserters. Each differs from the others as to where elementsare inserted: back_inserter creates an iterator that uses push_back. front_inserter creates an iterator that uses push_front. inserter creates an iterator that uses insert. This function takes a second argument, which must be an iterator into the given container. Elements are inserted ahead of the element denoted by the given iterator. It is important to understand that when we call inserter(c, iter), we get an iterator that, when used successively, inserts elements ahead of the element originally denoted by iter. That is, if it is an iterator generated by inserter, then an assignment such as *it = va1; behaves as: it = c.insert(it, val); // it points to the newly added element ++it; // increment it so that it denotes the same element as before iostream IteratorsEven though the iostream types are not containers, there are iterators that can be used with objects of the IO types. An istream_iterator reads an input stream, and an ostream_iterator writes an output stream. This part as a expand you can read chapter10 section 4 in c++ primer 5th. Structure of Generic AlgorithmsThe most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Some algorithms, such as find, require only the ability to access an element through the iterator, to increment the iterator, and to compare two iterators for equality. Others, such as sort, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five iterator categories listed in next table. Each algorithm specifies what kind of iterator must be supplied for each of its iterator parameters. Type Characteristics Input iterator Read, Increment only Output iterator Write, Increment only Forward iterator Read and write, Increment only Bidirectional iterator Read and write, Increment and Descrement Random_access iterator Read and write, full iterator arithmetic The Iterator Categories Input iterators: can read elements in a sequence. An input iterator must provide Equality and inequality operators (==, !=) to compare two iterators Prefix and postfix increment (++) to advance the iterator Dereference operator (*) to read an element; dereference may appear only on the right-hand side of an assignment The arrow operator (-&gt;) as a synonym for (* it).member—that is, dereference the iterator and fetch a member from the underlying object. Output iterators: can be thought of as having complementary functionality to input iterators; they write rather than read elements. Output iterators must provide Prefix and postfix increment (++) to advance the iterator Dereference (*), which may appear only as the left-hand side of an assignment (Assigning to a dereferenced output iterator writes to the underlying element.) Forward iterators: can read and write a given sequence. They move in only one direction through the sequence. Forward iterators support all the operations of both input iterators and output iterators. Bidirectional iterators: can read and write a sequence forward or backward. In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (--) operators. Random-access iterators: provide constant-time access to any position in the sequence. These iterators support all the functionality of bidirectional iterators. Container-Specific AlgorithmsUnlike the other containers, list and forward_list define several algorithms as members. In particular, the list types define their own versions of sort, merge, remove, reverse, and unique. you can see details in here.","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch5) Sequential Containers","slug":"c++ c5","date":"2021-12-22T13:52:45.000Z","updated":"2023-04-21T08:45:00.503Z","comments":true,"path":"2021/12/22/c++ c5/","link":"","permalink":"https://noahbishop.github.io/2021/12/22/c++%20c5/","excerpt":"","text":"Sequential ContainersOverview of the Sequential Containersexcept vector, string and array, there are some new sequential containers: deque, list and forward_list. Their characteristics show in next table: Type Characteristics deque Double-end queue, support random access list Doubly linked list, only support sequential access forward_list Singly linked list, only support sequential access With the exception of array, which is a fixed-size container, the containers provide efficient, flexible memory management. We can add and remove elements, growing and shrinking the size of the container. string and vector hold their elements in contiguous memory. Because elements are contiguous, it is fast to compute the address of an element from its index. However, adding or removing elements in the middle of one of these containers need take more time. The list and forward_list containers are designed to make it fast to add or remove an element anywhere in the container. In exchange, these types do not support random access to elements. A deque is a more complicated data structure. Like string and vector, deque supports fast random access and adding or removing elements in the middle of a deque is a (potentially) expensive operation. However, adding or removing elements at either end of the deque is a fast operation, comparable to adding an element to a list or forward_list. Container Library OverviewThe operations on the container types form a kind of hierarchy, this table show the type of container: member type definition value_type The first template parameter (T) allocator_type The second template parameter (Alloc) reference value_type&amp; pointer allocator_traits&lt;allocator_type&gt;::pointer iterator a random access iterator to value_type const_(reference\\ pointer\\ iterator) ~ difference_type a signed integral type, identical to distance between two iterator size_type an unsigned integral type that can represent any non-negative value of difference_type This table show the normal operation: method definition begin Return iterator to beginning end Return iterator to end cbegin Return const iterator to beginning cend Return const iterator to end swap swap elements in two containers size the number of elements in container max_size the max number of elements container can hold capacity Return size of allocated storage capacity The containers are class templates. As with vectors, we must supply additional information to generate a particular container type. Almost any type can be used as the element type of a sequential container. In particular, we can define a container whose element type is itself another container. We define such containers exactly as we do any other container type: We specify the element type (which in this case is a container type) inside angle brackets: vector&lt;vector&lt;string&gt;&gt; lines; // vector of vectors vector&lt;vector&lt;string&gt; &gt;; //Older compilers may require a space between the angle brackets IteratorsAn iterator range is denoted by a pair of iterators each of which refers to an element, or to one past the last element, in the same container. These two iterators, often referred to as begin and end—or (somewhat misleadingly) as first and last—mark a range of elements from the container. The name last, although commonly used, is a bit misleading, because the second iterator never refers to the last element of the range. Instead, it refers to a point one past the last element. This element range is called a left-inclusive interval. The standard mathematical notation for such a range is [begin, end). begin and end MembersThe begin and end operations yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container. The versions with an r return reverse iterators. Those that start with a c return the const version of the related iterator: list&lt;string&gt; a = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;; auto it1 = a.begin(); // list&lt;string&gt;::iterator auto it2 = a.rbegin(); // list&lt;string&gt;::reverse_iterator auto it3 = a.cbegin(); // list&lt;string&gt;::const_iterator auto it4 = a.crbegin();// list&lt;string&gt;::const_reverse_iterator Assignment and swapThe assignment-related operators act on the entire container. The assignment operator replaces the entire range of elements in the left hand container with copies of the elements from the right-hand operand: int main() &#123; vector&lt;int&gt; k(10, 20); vector&lt;int&gt; m(5, 40); k = m; for (auto i = k.begin(); i != k.cend(); i++) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; return 0; &#125; //output 40 40 40 40 40 The assignment operator requires that the left-hand and right-hand operands have the same type. It copies all the elements from the right-hand operand into the left-hand operand. The sequential containers (except array) also define a member named assign that lets us assign from a different but compatible type, or assign from a subsequence of a container. int main() &#123; vector&lt;char&gt; k(10, &#39;A&#39;); vector&lt;int&gt; m(5, 40); k.assign(m.begin(), m.end()); for (auto i = k.begin(); i != k.cend(); i++) &#123; cout &lt;&lt; *i &lt;&lt; &quot;&quot;; &#125; return 0; &#125; //output ( ( ( ( ( A second version of assign takes an integral value and an element value. It replaces the elements in the container with the specified number of elements, each of which has the specified element value: list&lt;string&gt; slist1(1); // one element, which is the empty string slist1.assign(10, &quot;Hiya!&quot;); // ten elements; each one is Hiya ! The swap operation exchanges the contents of two containers of the same type. After the call to swap, the elements in the two containers are interchanged: int main() &#123; vector&lt;int&gt; k(5, 20); vector&lt;int&gt; m(5, 40); k.swap(m); for (auto i = k.begin(); i != k.cend(); i++) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; for (auto i = m.begin(); i != m.cend(); i++) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; return 0; &#125; //output 40 40 40 40 40 20 20 20 20 20 Sequential Container OperationsAdd elementsExcepting array, all of the library containers provide flexible memory management. We can add or remove elements dynamically changing the size of the container at run time. push_back appends an element to the back of a vector. Aside from array and forward_list, every sequential container (including the string type) supports push_back. The call to push_back creates a new element at the end of container, increasing the size of container by 1. The value of that element is a copy of word. The type of container can be any of list, vector, or deque. Because string is just a container of characters, we can use push_back to add characters to the end of the string: int main() &#123; string s1 = &quot;hell&quot;; s1.push_back(&#39;o&#39;); // s1 is hello return 0; &#125; In addition to push_back, the list, forward_list, and deque containers support an analogous operation named push_front. This operation inserts a new element at the front of the container: int main() &#123; deque&lt;int&gt; k(1, 5); k.push_back(6); k.push_front(4); return 0; &#125; // k is a deque with elemrnts 4,5,6 More generally, the insert members let us insert zero or more elements at any point in the container. The insert members are supported for vector, deque, list, and string. Each of the insert functions takes an iterator as its first argument. The iterator indicates where in the container to put the element(s). int main() &#123; vector&lt;int&gt; k = &#123; 1,2,4,5 &#125;; auto it = k.begin(); it += 2; k.insert(it, 3); return 0; &#125; //k is a vector with elements 1,2,3,4,5 The arguments to insert that appear after the initial iterator argument are analogous to the container constructors that take the same parameters. The version that takes an element count and a value adds the specified number of identical. int main() &#123; vector&lt;int&gt; k; // k = &#123;1&#125; k.insert(k.end(), 1, 1); // k = &#123;1,2,3&#125; k.insert(k.end(), &#123; 2,3 &#125;); // k = &#123;1,2,3,4,5&#125; vector&lt;int&gt; t = &#123; 4,5 &#125;; k.insert(k.end(), t.begin(), t.end()); return 0; &#125; Under the new standard, the versions of insert that take a count or a range return an iterator to the first element that was inserted. (In prior versions of the library, these operations returned void.) We can use the value returned by insert to repeatedly insert elements at a specified position in the container: int main() &#123; vector&lt;int&gt; k; auto iter = k.begin(); for (int i = 0; i &lt; 5; i++) &#123; iter = k.insert(iter, i); &#125; return 0; &#125; // k = &#123;4,3,2,1,0&#125; The new standard introduced three new members—emplace_front, emplace, and emplace_back—that construct rather than copy elements. These operations correspond to the push_front, insert, and push_back operations in that they let us put an element at the front of the container, in front of a given position, or at the back of the container, respectively. c.emplace_back(&quot;978-0590353403&quot;, 25, 15.99); c.push_back(Sales_data(&quot;978-0590353403&quot;, 25, 15.99)); The call to emplace_back and the second call to push_back both create new Sales_data objects. In the call to emplace_back, that object is created directly in space managed by the container. The call to push_back creates a local temporary object that is pushed onto the container. Accessing ElementsEach sequential container, including array, has a front member, and all except forward_list also have a back member. These operations return a reference to the first and last element, respectively: if (!c.empty()) &#123; // val and val2 are copies of the value of the first element in c auto val = *c.begin(), val2 = c.front(); // val3 and val4 are copies of the of the last element in c auto last = c.end(); auto val3 = *(--last); // can&#39;t decrement forward_list iterators auto val4 = c.back(); // not supported by forward_list &#125; The containers that provide fast random access (string, vector, deque, and array) also provide the subscript operator []. As we’ve seen, the subscript operator takes an index and returns a reference to the element at that position in the container. The index must be “in range” (i.e., greater than or equal to 0 and less than the size of the container). It is up to the program to ensure that the index is valid; the subscript operator does not check whether the index is in range. Using an out-of-range value for an index is a serious programming error, but one that the compiler will not detect. If we want to ensure that our index is valid, we can use the at member instead. The at member acts like the subscript operator, but if the index is invalid, at throws an out_of_range exception. Erasing ElementsJust as there are several ways to add elements to a (no-array) container there are also several ways to remove elements. The pop_front and pop_back functions remove the first and last elements, respectively. Just as there is no push_front for vector and string, there is also no pop_front for those types. Similarly, forward_list does not have pop_back. Like the element access members, we may not use a pop operation on an empty container. int main() &#123; deque&lt;int&gt; k = &#123; 1,1,2,3,3 &#125;; k.pop_back(); k.pop_front(); return 0; &#125; // k = &#123;1,2,3&#125; The erase members remove element(s) at a specified point in the container. We can delete a single element denoted by an iterator or a range of elements marked by a pair of iterators. Both forms of erase return an iterator referring to the location after the (last) element that was removed. int main() &#123; list&lt;int&gt; lst = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; auto it = lst.begin(); while (it != lst.end()) if (*it % 2) // if the element is odd it = lst.erase(it); // erase this element else ++it; return 0; &#125; delete a range of elements: int main() &#123; vector&lt;int&gt; lst = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; auto it_beg = lst.begin(); auto it_end = lst.begin() + 5; lst.erase(it_beg, it_end); return 0; &#125; // lst = &#123;5,6,7,8,9&#125; Resizing a ContainerWith the usual exception of arrays, we can use resize, to make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container: list&lt;int&gt; ilist(10, 42); // ten ints: each has value 42 ilist.resize(15); // adds five elements of value 0 to the back of ilist ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist ilist.resize(5); // erases 20 elements from the back of ilist How a vector GrowsTo support fast random access, vector elements are stored contiguously—each element is adjacent to the previous element. If there is no room for the new element, the container can’t just add an elementsomewhere else in memory—the elements must be contiguous. Instead, the container must allocate new memory to hold the existing elements plus the new one, move the elements from the old location into the new space, add the new element, and deallocate the old memory. If vector did this memory allocation and deallocation each time we added an element, performance would be unacceptably slow. To avoid these costs, library implementors use allocation strategies that reduce the number of times the container is reallocated. It is important to understand the difference between capacity and size. The size of a container is the number of elements it already holds; its capacity is how many elements it can hold before more space must be allocated. A vector may be reallocated only when the user performs an insert operation when the size equals capacity or by a call to resize or reserve with a value that exceeds the current capacity. How much memory is allocated beyond the specified amount is up to the implementation. int main() &#123; vector&lt;int&gt; ivec(50, 1); cout &lt;&lt; ivec.capacity() &lt;&lt; endl; ivec.push_back(1); cout &lt;&lt; ivec.capacity() &lt;&lt; endl; return 0; &#125; // in my computer the output is // 50 // 100 Additional string OperationsSubstring And ReplaceThe substr operation returns a string that is a copy of part or all of the original string. We can pass substr an optional starting position and count: string s(&quot;hello world&quot;); string s2 = s.substr(0, 5); // s2 = hello string s3 = s.substr(6); // s3 = world string s4 = s.substr(6, 11); // s3 = world string s5 = s.substr(12); // throws an out_of_range exception The string type supports the sequential container assignment operators and the assign, insert, and erase operations, It also defines additional versions of insert and erase. string provides versions that take an index. The index indicates the starting element to erase or the position before which to insert the given values: string s = &quot;hello&quot;; // insert five exclamation points at the end of s // s = “Hello!!!!!!” s.insert(s.size(), 5, &#39;!&#39;); s.erase(s.size() - 5, 5); // erase the last five characters from s The string class defines two additional members, append and replace, that can change the contents of a string. The append operation is a shorthand way of inserting at the end: int main() &#123; string s(&quot;C++ Primer&quot;); // initialize s and s2 to &quot;C++Primer s.append(&quot; 4th Ed.&quot;); cout &lt;&lt; s &lt;&lt; endl; s.replace(11, 3, &quot;5th&quot;); cout &lt;&lt; s &lt;&lt; endl; return 0; &#125; // output // C++ Primer 4th Ed. // C++ Primer 5th Ed. Find functionThe string class provides six different search functions, each of which has four overloaded versions. The next table describes the search members and their definition. Each of these search operations returns a string::size_type value that is the index of where the match occurred. If there is no match, the function returns a static member (§ 7.6, p. 300) named string::npos. The library defines npos asa const string::size_type initialized with the value -1. Because npos is an unsigned type, this initializer means npos is equal to the largest possible size any string could have. method definition find Find first occurrence of content in string rfind Find last occurrence of content in string find_first_of Find any character match in string find_last_of Find character in string from the end find_first_not_of Find absence of character in string find_last_not_of Find non-matching character in string from the end int main() &#123; string s(&quot;AA BB AA DD AA BB AA&quot;); // return the first match position auto pos = s.find(&quot;AA&quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; //return the last match position pos = s.rfind(&quot;AA&quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; // return the first char match position pos = s.find_first_of(&quot;DB&quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; // return the last char match position pos = s.find_last_of(&quot;DB&quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; // return the first char not in metch string pos = s.find_first_not_of(&quot;AB &quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; // return the last char not in metch string pos = s.find_last_not_of(&quot;AD &quot;); cout &lt;&lt; pos &lt;&lt; s.substr(pos) &lt;&lt; endl; return 0; &#125; //output //0AA BB AA DD AA BB AA //18AA //3BB AA DD AA BB AA //16B AA //9DD AA BB AA //16B AA We can pass an optional starting position to the find operations. This optional argument indicates the position from which to start the search. By default, that position is set to zero. One common programming pattern uses this optional argument to loop through a string finding all occurrences: string::size_type pos = 0; // each iteration finds the next number in name while ((pos = name.find_first_of(numbers, pos))!= string::npos) &#123; cout &lt;&lt; &quot;found number at index: &quot; &lt;&lt; pos &lt;&lt; &quot; element is &quot; &lt;&lt; name[pos] &lt;&lt; endl; ++pos; // move to the next character &#125; CompareIn addition to the relational operators, the string library provides a set of compare functions that are similar to the C library strcmp function. The function compare returns zero or a positive or negative value depending on whether s is equal to, greater than, or less than the string formed from the given arguments. int main() &#123; std::string str1(&quot;green apple&quot;); std::string str2(&quot;red apple&quot;); if (str1.compare(str2) != 0) std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; endl; if (str1.compare(6, 5, &quot;apple&quot;) == 0) std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple&quot; &lt;&lt; endl; if (str2.compare(str2.size() - 5, 5, &quot;apple&quot;) == 0) std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple&quot; &lt;&lt; endl; if (str1.compare(6, 5, str2, 4, 5) == 0) std::cout &lt;&lt; &quot;therefore, both are apples&quot; &lt;&lt; endl; return 0; &#125; //output //green apple is not red apple //still, green apple is an apple //and red apple is also an apple //therefore, both are apples previous code show the most common usage, more details you can check this website. Numeric ConversionsStrings often contain characters that represent numbers. In c++ 11 the new standard introduced several functions that convert between numeric data and library strings: int main() &#123; // converts the double i to its character representation // note output the i and s is different double i = 42.97538045793466769837795; string s = to_string(i); cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; s &lt;&lt; endl; // converts a string to double string k = &quot;1999.9&quot;; double tod = stod(k); // converts a string to int string j = &quot;6745&quot;; int toi = stoi(k); return 0; &#125; the function that string to numeric type can be think prefix sto add a suffix represent the numeric type, stoi means string to int, stof means string to float. etc… Container AdaptorsIn addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue. An adaptor is a general concept in the library. There are container, iterator, and function adaptors. Essentially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different type. Defining an AdaptorEach adaptor defines two constructors: the default constructor that creates an empty object, and a constructor that takes a container and initializes the adaptor by copying the given container. deque&lt;int&gt; mydeque = &#123; 1,2,3,4,5 &#125;; // empty stack stack&lt;int&gt; myst1; // copies elements from deq into stk stack&lt;int&gt; myst2(mydeque); By default both stack and queue are implemented in terms of deque, and a priority_queue is implemented on a vector. We can override the default container type by naming a sequential container as a second type argument when we create the adaptor: int main() &#123; vector&lt;string&gt; svec = &#123; &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot; &#125;; // empty stack implemented on top of vector stack&lt;string, vector&lt;string&gt;&gt; str_stk; // str_stk2 is implemented on top of vector and initially holds a copy of svec stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec); return 0; &#125; A stack requires only push_back, pop_back, and back operations, so we can use any of the remaining container types for a stack. A queue adaptor requires back, push_back, front, and push_front, so it can be built on alist or deque but not on a vector. A priority_queue requires random access in addition to the front, push_back, and pop_back operations; it can be built on a vector or a deque but not on a list. Stack AdaptorThe three most common methods in stack are push, pop, top, the push add a element to the top of stack, the pop remove a element to the top of stack, the top return the top of stack. int main() &#123; stack&lt;int&gt; m; // add 1,2,3,4,5 by sequential for (int i = 0; i &lt; 5; i++) &#123; m.push(i); &#125; // pop elemrnt for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; m.top() &lt;&lt; &quot; &quot;; m.pop(); &#125; cout &lt;&lt; endl; return 0; &#125; //output //4 3 2 1 0 The Queue AdaptorsThe queue and priority_queue adaptors are defined in the queue header. The library queue uses a first-in, first-out (FIFO) storage and retrieval policy. Objects entering the queue are placed in the back and objects leaving the queue are removed from the front. A restaurant that seats people in the order in which they arrive is an example of a FIFO queue. The four most common methods in queue are push, pop, front, back, top push: add a element to end of queue pop: remove a element in the head of queue front: return a element from the head of queue back: return a element in the end of queue (only valid in queue) top: return the most priority element in priority_queue (only valid in priority_queue) A priority_queue lets us establish a priority among the elements held in the queue. Newly added elements are placed ahead of all the elements with a lower priority. A restaurant that seats people according to their reservation time, regardless of when they arrive, is an example of a priority queue. By default, the library uses the &lt; operator on the element type to determine relative priorities. However we can override the default. int main() &#123; queue&lt;int&gt; m; // add 1,2,3,4,5 by sequential for (int i = 0; i &lt; 5; i++) &#123; m.push(i); &#125; // pop elemrnt for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; m.front() &lt;&lt; &quot; &quot;; m.pop(); &#125; cout &lt;&lt; endl; return 0; &#125; //0 1 2 3 4","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch4) The C++ IO Library","slug":"c++ c4","date":"2021-12-21T13:52:45.000Z","updated":"2023-04-21T08:44:58.887Z","comments":true,"path":"2021/12/21/c++ c4/","link":"","permalink":"https://noahbishop.github.io/2021/12/21/c++%20c4/","excerpt":"","text":"The IO LibraryThe IO ClassesThe IO types and objects that we have used so far manipulate char data. By default these objects are connected to the user’s console window. Of course, real programs cannot be limited to doing IO solely to or from a console window. Programs often need to read or write named files. Moreover, it can be convenient to use IO operations to process the characters in a string. Applications also may have to read and write languages that require wide-character support. To support these different kinds of IO processing, the library defines a collection of IO types in addition to the istream and ostream types that we have already used. These types are defined in three separate headers: Header use iostream read from and write to a stream fstream read and write named files sstream read and write in-memory strings As we saw in previous, we cannot copy or assign objects of the IO types, so we cannot have a parameter or return type that is one of the stream types. Functions that do IO typically pass and return the stream through references. Inherent in doing IO is the fact that errors can occur. Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct. The IO classes define functions and flags let us access and manipulate the condition state of a stream.(*stream represent one of streams in previous table) name meaning *stream::iostate Type for stream state flags *stream::eofbit End-Of-File reached while performing an extracting operation on an input stream. *stream::failbit The last input operation failed because of an error related to the internal logic of the operation itself. *stream::badbit Error due to the failure of an input/output operation on the stream buffer. *stream::goodbit No error. Represents the absence of all the above (the value zero). The more details you can read in here. As an example of an IO error, consider the following code:int ival; cin &gt;&gt; ival;, If we enter Boo on the standard input, the read will fail. The input operator expected to read an int but got the character B instead. As a result, cin will be put in an error state. Similarly, cin will be in an error state if we enter an end-of-file. Once an error has occurred, subsequent IO operations on that stream will fail. We can read from or write to a stream only when it is in a non-error state. File Input and OutputThe fstream header defines three types to support file IO: ifstream to read from a given file, ofstream to write to a given file, and fstream, which reads and writes a given file. These types provide the same operations as those we have previously used on the objects cin and cout. In particular, we can use the IO operators (&lt;&lt; and &gt;&gt;) to read and write files, we can use getline to read an ifstream. In addition to the behavior that they inherit from the iostream types, the types defined in fstream add members to manage the file associated with the stream. These operations, listed in next table, can be called on objects of fstream, ifstream, or ofstream but not on the other IO types. use meaning fstream fstrm; created a unbound file stream. fstream fstrm(s); created a file stream and open file called s fstream fstrm(s,mode); like previous, but with special mode. fstrm.open(s) Opens the file identified by argument filename fstrm.open(s,mode) like previous, but with special mode. fstrm.close() Closes the file currently associated with the object, disassociating it from the stream. fstrm.is_open() Returns whether the stream is currently associated to a file. When we want to read or write a file, we define a file stream object and associate that object with the file. Each file stream class defines a member function named open that does whatever system-specific operations are required to locate the given file and open it for reading or writing as appropriate. When we create a file stream, we can (optionally) provide a file name. When we supply a file name, open is called automatically, this is a simple example that create question and answer question program, the question and answer will be save in file. #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; int main() &#123; //file path std::string ans_file = &quot;Answer.txt&quot;; std::string que_file = &quot;Question.txt&quot;; // created question std::ifstream in; std::ofstream out; out.open(que_file); out &lt;&lt; 300 &lt;&lt; &quot; &quot; &lt;&lt; 400; out.close(); //answer the question in.open(que_file); int num1, num2, sum; in &gt;&gt; num1 &gt;&gt; num2; sum = num1 + num2; out.open(ans_file); out &lt;&lt; sum; //read answer in.close(); in.open(ans_file); in &gt;&gt; sum; std::cout &lt;&lt; sum &lt;&lt; std::endl; return 0; &#125; When we define an empty file stream object, we can subsequently associate that object with a file by calling open, If a call to open fails, failbit is set. Because a call to open might fail, it is usually a good idea to verify that the open succeeded: if(out)&#123; /**/ &#125; Once a file stream has been opened, it remains associated with the specified file. Indeed, calling open on a file stream that is already open will fail and set failbit. Subsequent attempts to use that file stream will fail. To associate a file stream with a different file, we must first close the existing file. Once the file is closed, we can open a new one. Each stream has an associated file mode that represents how the file may be used. Next table lists the file modes and their meanings. member constant stands for access in input File open for reading: the internal stream buffer supports input operations. out output File open for writing: the internal stream buffer supports output operations. binary binary Operations are performed in binary mode rather than text. ate at end The output position starts at the end of the file. app append All output operations happen at the end of the file, appending to its existing contents. trunc trunc ate Any contents that existed in the file before it is open are discarded. We can supply a file mode whenever we open a file—either when we call open or when we indirectly open the file when we initialize a stream from a file name. The modes that we can specify have the following restrictions: out may be set only for an ofstream or fstream object. in may be set only for an ifstream or fstream object. trunc may be set only when out is also specified app mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode, even if out was not explicitly specified. The ate and binary modes may be specified on any file stream object type and in combination with any other file modes. By default, when we open an ofstream, the contents of the file are discarded. The only way to prevent an ostream from emptying the given file is to specify app. string StreamsThe sstream header defines three types to support in-memory IO; these types read from or write to a string as if the string were an IO stream. The istringstream type reads a string, ostringstream writes a string, and stringstream reads and writes the string. Like the fstream types, the types defined in sstream inherit from the types we have used from the iostream header. In addition to the operations they inherit, the types defined in sstream add members to manage the string associated with the stream. These operations are listed in next table. They may be called on stringstream objects but not on the other IO types. use meaning sstream strm; unbound string stream sstream strm(s); string stream bound to string s strm.str() return a string that strm holds strm.str(s) copy string s to strm An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line. As one example, assume we have a file that lists people and their associated phone numbers. Some people have only one number, but others have several—a home phone, work phone, cell number, and so on. Our input file might look like the following:morgan 2015552368 8625550123, drew 9735550130, lee 6095550132 2015550175 8005550000. #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;vector&gt; class Info &#123; public: //constructor Info(std::string n) : name(n) &#123;&#125; //add more phone number void add_phone(std::string ph) &#123; phone.push_back(ph); &#125; //print information void print(std::ostream&amp; os) &#123; os &lt;&lt; &quot;Name: &quot; &lt;&lt; &quot;\\n&quot;; int count = 1; for (auto i = phone.begin(); i &lt; phone.end(); i++) &#123; os &lt;&lt; &quot;phone&quot; &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; *i &lt;&lt; &quot;\\n&quot;; &#125; os &lt;&lt; &quot;\\n&quot;; &#125; private: std::string name; std::vector&lt;std::string&gt; phone; &#125;; int main() &#123; std::istringstream in; std::string info; std::vector&lt;Info&gt; contacts; while (getline(std::cin,info)) &#123; in.str(info); std::string name; std::string phone_number; // read name and create contact in &gt;&gt; name; Info peo(name); //read phone number while (in &gt;&gt; phone_number) &#123; peo.add_phone(phone_number); &#125; contacts.push_back(peo); for (auto i = contacts.begin(); i &lt; contacts.end(); i++) &#123; i-&gt;print(std::cout); &#125; &#125; return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch3) C++ Basic Features - Operators And Statements","slug":"c++ c3","date":"2021-12-20T13:52:45.000Z","updated":"2023-04-21T08:44:57.450Z","comments":true,"path":"2021/12/20/c++ c3/","link":"","permalink":"https://noahbishop.github.io/2021/12/20/c++%20c3/","excerpt":"","text":"C++ Basic Features - Operators And StatementsExpressionsC++ provides a rich set of operators and defines what these operators do when applied to operands of built-in type. It also allows us to define the meaning of most of the operators when applied to operands of class types. This chapter focuses on the operators as defined in the language and applied to operands of built-in type. An expression is composed of one or more operands and yields a result when it is evaluated. The simplest form of an expression is a single literal or variable. The result of such an expression is the value of the variable or literal. More complicated expressions are formed from an operator and one or more operands. FundamentalsThe basic concept of expressions are operator and operands, the operator can be classified by operands, Unary operators, such as address-of (&amp;) and dereference (*), act on one operand. Binary operators, such as equality (==) and multiplication (*), act on two operands. There is also one ternary operator that takes three operands, and one operator, function call, that takes an unlimited number of operands. Understanding expressions with multiple operators requires understanding the precedence and associativity of the operators and may depend on the order of evaluation of the operands. For example, 5 + 7 * 9, the * has high precedence. The language defines what the operators mean when applied to built-in and compound types. We can also define what most operators mean when applied to class types. Because such definitions give an alternative meaning to an existing operator symbol, we refer to them as overloaded operators. The IO library &gt;&gt; and &lt;&lt; operators and the operators we used with strings, vectors, and iterators are all overloaded operators. When you write compound expressions, two rules of thumb can be helpful: When in doubt, parenthesize expressions to force the grouping that the logic of your program requires. If you change the value of an operand, don’t use that operand elsewhere in the same expression. Arithmetic OperatorsThe next table show arithmetic operators in c++ order by precedence. Operator function expression + unary plus + operand1 - unary minus - operand1 * multiplication operand1 * operand2 / division operand1 / operand2 % reminder operand1 % operand2 + addition operand1 + operand2 - subtraction operand1 - operand2 Note same operator has different meaning with different type of operand, when division a integer, like 5 / 2, the result is 2 rather than 2.5. Logical and Relational OperatorsThe relational operators take operands of arithmetic or pointer type; the logical operators take operands of any type that can be converted to bool. These operators all return values of type bool. Arithmetic and pointer operand(s) with a value of zero are false; all other values are true. The operands to these operators are rvalues and the result is an rvalue. Operator function expression ! logical not ! operand &gt; greater than operand1 &gt; operand2 &gt;= greater than or equal operand1 &gt;= operand2 &lt; less than operand1 &lt; operand2 &lt;= less than or equal operand1 &lt;= operand2 == equal operand1 == operand2 != unequal operand1 != operand2 &amp;&amp; logical and operand1 &amp;&amp; operand2 \\ \\ logical or operand1 \\ \\ operand2 The Member Access OperatorsThe dot . and arrow -&gt; operators provide for member access. The dot operator fetches a member from an object of class type; arrow is defined so that ptr-&gt;mem is a synonym for (*ptr).mem: The Conditional OperatorThe conditional operator (the ?: operator) lets us embed simple if-else logic inside an expression. The conditional operator has the following form: cond ? expr1 : expr2;. where cond is an expression that is used as a condition and expr1 and expr2 are expressions of the same type (or types that can be converted to a common type). This operator executes by evaluating cond. If the condition is true, then expr1 is evaluated; otherwise, expr2 is evaluated. As one example, we can use a conditional operator to determine whether a grade is pass or fail: The Bitwise OperatorsThe bitwise operators take operands of integral type that they use as a collection of bits. These operators let us test and set individual bits. We can also use these operators on a library type named bitset that represents a flexibly sized collection of bits Operator function expression ~ bitwise not ~ operand &gt;&gt; right shift operand1 &gt;&gt; operand2 &lt;&lt; left shift operand1 &lt;&lt; operand2 &amp; bitwise and operand1 &amp; operand2 ^ bitwise xor operand1 ^ operand2 \\ bitwise or operand1 \\ operand2 The sizeof OperatorThe sizeof operator returns the size, in bytes, of an expression or a type name. The operator is right associative. The result of sizeof is a constant expression of type size_t. The operator takes one of two forms: sizeof (type) and sizeof expr. sizeof(int); int a = 10; sizeof a; Type Explicit ConversionsA named cast has the following form:cast-name&lt;type&gt;(expression); where type is the target type of the conversion, and expression is the value to be cast. If type is a reference, then the result is an lvalue. The cast-name may be one of static_cast, dynamic_cast, const_cast, and reinterpret_cast. A static_cast is often useful when a larger arithmetic type is assigned to a smaller type. The cast informs both the reader of the program and the compiler that we are aware of and are not concerned about the potential loss of precision. A static_cast is also useful to perform a conversion that the compiler will not generate automatically. For example, we can use a static_cast to retrieve a pointer value that was stored in a void* pointer: float a = 1; void* p = &amp;a; // *k equal to 1065353216 (IEEE 754) // *l equal to 1 int *k = static_cast&lt;int*&gt;(p); float *l = static_cast&lt;float*&gt;(p); A const_cast changes only a low-level const in its operand: const int *a; auto p = const_cast&lt;int*&gt;(a); *p = 10; // ok *a = 10; // error Conventionally we say that a cast that converts a const object to a nonconst type “casts away the const.” Once we have cast away the const of an object, the compiler will no longer prevent us from writing to that object. If the object was originally not a const, using a cast to obtain write access is legal. However, using a const_cast in order to write to a const object is undefined. StatementsLike most languages, C++ provides statements for conditional execution, loops that repeatedly execute the same body of code, and jump statements that interrupt the flow of control. This chapter looks in detail at the statements supported by C++. The almost statements are same as other language like java, and be used in previous code, so the next only show some new features. try Blocks and Exception HandlingExceptions are run-time anomalies—such as losing a database connection or encountering unexpected input—that exist outside the normal functioning of a program. Dealing with anomalous behavior can be one of the most difficult parts of designing any system. In C++, exception handling involves: throw expressions, which the detecting part uses to indicate that it encountered something it can’t handle. We say that a throw raises an exception. try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses. A set of exception classes that are used to pass information about what happened between a throw and an associated catch. Supposed wo want write a program that need read two numbers and then will do division, as we know, zero can’t be divisor. We need throw a arithmetic error if divisor is zero. #include &lt;iostream&gt; int main() &#123; int num1, num2; while (std::cin &gt;&gt; num1 &gt;&gt; num2)&#123; if (num2 == 0)&#123; throw std::runtime_error(&quot;divisor can&#39;t be zero!&quot;); &#125;else&#123; std::cout &lt;&lt; num1 &lt;&lt; &quot;/&quot; &lt;&lt; num2 &lt;&lt; &quot;=&quot; &lt;&lt; num1 / num2 &lt;&lt; std::endl; &#125; &#125; return 0; &#125; Only throw error is no a good idea, we also need catch the error so that program will continued running, and report the error to user: #include &lt;iostream&gt; int main() &#123; int num1, num2; while (std::cin &gt;&gt; num1 &gt;&gt; num2) &#123; try&#123; if (num2 == 0) &#123; throw std::runtime_error(&quot;divisor can&#39;t be zero!&quot;); &#125; else &#123; std::cout &lt;&lt; num1 &lt;&lt; &quot;/&quot; &lt;&lt; num2 &lt;&lt; &quot;=&quot; &lt;&lt; num1 / num2 &lt;&lt; std::endl; &#125; &#125; catch (std::runtime_error err)&#123; std::cout &lt;&lt; err.what() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;please input a correct divisor&quot; &lt;&lt; std::endl; &#125; &#125; return 0; &#125; If no appropriate catch is found, execution is transferred to a library function named terminate. The behavior of that function is system dependent but is guaranteed to stop further execution of the program. Exceptions that occur in programs that do not define any try blocks are handled in the same manner: After all, if there are no try blocks, there can be no handlers. If a program has no try blocks and an exception occurs, then terminate is called and the program is exited. The C++ library defines several classes that it uses to report problems encountered in the functions in the standard library. These exception classes are also intended to be used in the programs we write. These classes are defined in four headers: The exception header defines the most general kind of exception class named exception. It communicates only that an exception occurred but provides no additional information. The stdexcept header defines several general-purpose exception classes. The new header defines the bad_alloc exception type. The type_info header defines the bad_cast exception type. Functions And ClassesFunctionA function is a block of code with a name. We execute the code by calling the function. A function may take zero or more arguments and (usually) yields a result. Functions can be overloaded, meaning that the same name may refer to several different functions. Function BasicsA function definition typically consists of a return type, a name, a list of zero or more parameters, and a body. The parameters are specified in a comma-separated list enclosed in parentheses. The actions that the function performs are specified in a statement block, referred to as the function body. example: int fact(int n) &#123; //The factorial of n int sum = 1; while (n&gt;0) &#123; sum *= n--; &#125; return sum; &#125; To call fact, we must supply an int value. The result of the call is also an int: int main() &#123; int f = 0; std::cin &gt;&gt; f; std::cout &lt;&lt; fact(f) &lt;&lt; std::endl; return 0; &#125; A function call does two things: It initializes the function’s parameters from the corresponding arguments. It transfers control to that function. Execution of the calling function is suspended and execution of the called function begins. Most types can be used as the return type of a function. In particular, the return type can be void, which means that the function does not return a value. However, the return type may not be an array type or a function type. However, a function may return a pointer to an array or a function. In C++, names have scope, and objects have lifetimes. It is important to understand both of these concepts. The scope of a name is the part of the program’s text in which that name is visible. The lifetime of an object is the time during the program’s execution that the object exists. Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope. The objects that correspond to ordinary local variables are created when the function’s control path passes through the variable’s definition. They are destroyed when control passes through the end of the block in which the variable is defined. Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined. It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates. This program will print the numbers from 1 through 10 inclusive: size_t count_calls()&#123; static size_t ctr = 0; // value will persist across calls return ++ctr; &#125; int main()&#123; for (size_t i = 0; i != 10; ++i) cout &lt;&lt; count_calls() &lt;&lt; endl; return 0; &#125; Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times. A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body. Argument PassingAs we’ve seen, each time we call a function, its parameters are created and initialized by the arguments passed in the call. As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument’s value is copied. When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference.”When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value.” #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; void toUper1(char c) &#123; c = toupper(c); &#125; void toUper2(char &amp;c) &#123; c = toupper(c); &#125; int main()&#123; char c = &#39;a&#39;; //no effect, because c in to toUper1 is a copy of c in in to main toUper1(c); cout &lt;&lt; c &lt;&lt; endl;// print a //effect, because c in to toUper1 is bound to c in in to main toUper2(c); cout &lt;&lt; c &lt;&lt; endl;//print A return 0; &#125; Pointers behave like any other nonreference type. When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points. We can change the value of that object by assigning through the pointer: void toUper3(char *c) &#123; *c = toupper(*c); &#125; //note in mian wo call this function need pass the address of c //toUper3(&amp;c) It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied. As an example, we’ll write a function to compare the length of two strings. Because strings can be long, we’d like to avoid copying them, so we’ll make our parameters references. Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array’s first element. Even though we cannot pass an array by value, we can write a parameter that looks array: Regardless of appearances, these declarations are equivalent: Each declares a function with a single parameter of type const int*. When the compiler checks a call to print, it checks only that the argument has type const int*: void print(const int*); void print(const int[]); // shows the intent that the function takes an array void print(const int[10]); // dimension for documentation purposes (at best) Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters. A technique used to manage array arguments is to pass pointers to the first and one past the last element in the array. This approach is inspired by techniques used in the standard library. Using this approach, we’ll print the elements in an array as follows: #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; void print(const int *beg, const int *end) &#123; while (beg != end) &#123; cout &lt;&lt; *beg++ &lt;&lt; endl; &#125; &#125; int main()&#123; int arr[4] = &#123; 2,4,2,4 &#125;; print(std::begin(arr), std::end(arr)); return 0; &#125; Another approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array. Using this approach, we’ll rewrite print as follows: void print(const int ia[], size_t size) &#123; for (size_t i = 0; i != size; ++i) &#123; cout &lt;&lt; ia[i] &lt;&lt; endl; &#125; &#125; In c++ multidimensional array is an array of arrays. As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified: void print(int (*arr)[2], size_t size) &#123; for (size_t i = 0; i &lt; size; i++) &#123; auto beg = std::begin(*arr), end = std::end(*arr); while (beg != end) &#123; cout &lt;&lt; *beg++ &lt;&lt; endl; &#125; arr += 1; &#125; &#125; //We can also define our function using array syntax. void print(int arr[][2], size_t size) &#123; /* . . . */ &#125; Up to now, we have defined main with an empty parameter list: int main() &#123; ... &#125;, However, we sometimes need to pass arguments to main. The most common use of arguments to main is to let the user specify a set of options to guide the operation of the program. For example, assuming our main program is in an executable file named prog, we might pass options to the program as follows:prog -d -o ofile data0. Such command-line options are passed to main in two (optional) parameters: int main(int argc, char *argv[]) &#123; ... &#125;, The second parameter, argv, is an array of pointers to C-style character strings. Thefirst parameter, argc, passes the number of strings in that array. Sometimes we do not know in advance how many arguments we need to pass to a function. For example, we might want to write a routine to print error messages generated from our program. We’d like to use a single function to print these error messages in order to handle them in a uniform way. However, different calls to our error-printing function might pass different arguments, corresponding to different kinds of error messages. The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. You can see all details in here. void error_msg(std::initializer_list&lt;std::string&gt; il)&#123; for (auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces: error_msg(&#123; &quot;4tw&quot;, &quot;98ty8w&quot; &#125;); Return Types and the return StatementA return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements: return; and return expression;. A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function’s last statement. The second form of the return statement provides the function’s result. Every return in a function with a return type other than void must return a value. Note never return a reference or pointer to a local object, When a function completes, its storage is freed. After a function terminates, references to local objects refer to memory that is no longer valid: //don&#39;t do this std::string&amp; em() &#123; std::string str = &quot;iecbvasj&quot;; return str; &#125; A function that calls itself, either directly or indirectly, is a recursive function. As an example, we can rewrite our factorial function to use recursion: int factorial(int val)&#123; if (val &gt; 1) return factorial(val-1) * val; return 1; &#125; Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array. There are some ways to simplify such declarations, the most straightforward way is to use a type alias: typedef int arrT[10]; // arrT is a synonym for the type array of ten ints using arrT = int[10]; // equivalent declaration of arrT; arrT is a synonym for an array of ten ints. Because we cannot return an array, we define the return type as a pointer to this type. // a function that initiated a array arrT *init_arr(arrT *t)&#123; for (auto i = std::begin(*t); i != std::end(*t); i++)&#123; *i = 1; &#125; return t; &#125; To declare function without using a type alias, we must remember that the dimension of an array follows the name being defined: int (*init_arr1(int (*t)[10]))[10] &#123; for (auto i = std::begin(*t); i != std::end(*t); i++) &#123; *i = 1; &#125; return t; &#125; Under the new standard, another way to simplify the declaration of func is by using a trailing return type. Trailing returns can be defined for any function, but are most useful for functions with complicated return types, such as pointers (or references) to arrays. auto init_arr(arrT* t) -&gt; int(*)[10]&#123; for (auto i = std::begin(*t); i != std::end(*t); i++) &#123; *i = 1; &#125; return t; &#125; Overloaded FunctionsFunctions that have the same name but different parameter lists and that appear in the same scope are overloaded. For example, we want write a print function that print array with different parameter: void print(const char *cp); void print(const int *beg, const int *end); void print(const int ia[], size_t size); When we call these functions, the compiler can deduce which function we want based on the argument type we pass, Overloaded functions must differ in the number or the type(s) of their parameters. As we saw in previous top-level const has no effect on the objects that can be passed to the function. A parameter that has a top-level const is indistinguishable from one without a top-level const: int f1(const int a); int f1(int a); //same int f1(int *const a); int f1(int* a); //same In these declarations, the second declaration declares the same function as the first.But we can overload based on whether the parameter is a reference (or pointer) to the const or nonconst version of a given type; such consts are low-level: because a low level pointer or reference refer a const object, In these cases, the compiler can use the constness of the argument to distinguish which function to call: #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; int f1(const int* a) &#123; return 1; &#125; int f1(int* a) &#123; return 2; &#125; int f1(const int&amp; a) &#123; return 3; &#125; int f1(int&amp; a) &#123; return 4; &#125; int main() &#123; const int a = 0; int b = 0; cout &lt;&lt; f1(&amp;a) &lt;&lt; endl; //print 1 cout &lt;&lt; f1(&amp;b) &lt;&lt; endl; //print 2 cout &lt;&lt; f1(a) &lt;&lt; endl; //print 3 cout &lt;&lt; f1(b) &lt;&lt; endl; //print 4 return 0; &#125; Note overloading has no special properties with respect to scope: As usual, if we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes: #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; int z() &#123; return 10; &#125; int p() &#123; return 1; &#125; int main() &#123; bool z; int r = z(); //error: z is a bool object double p(int a); p(); //error: previous function is hided p(1); //ok return 0; &#125; Features for Specialized UsesIn this section we’ll cover three function-related features that are useful in many, but not all, programs: default arguments, inline and constexpr functions. Some functions have parameters that are given a particular value in most, but not all. In such cases, we can declare that common value as a default argument for the function. Functions with default arguments can be called with or without thatargument. For example, we want say hello to different program languages, in default case we say hello to c++ once: #include &lt;iostream&gt; #include &lt;string&gt; using std::cin; using std::cout; using std::endl; void hello(std::string s = &quot;C++&quot;, size_t n = 1) &#123; for (size_t i = 0; i &lt; n; i++) &#123; cout &lt;&lt; &quot;Hello &quot; &lt;&lt; s &lt;&lt; endl; &#125; &#125; int main() &#123; hello(); // say hello C++ once hello(&quot;Java&quot;); // say hello Java once hello(&quot;C#&quot;, 2);// say hello C# twice hello(3); // error: can omit only trailing arguments return 0; &#125; Sometimes we defining a function with such a small operation, the benefit of function are: It is easier to read and understand a call to function than it would be to read and understand the equivalent conditional expression. Using a function ensures uniform behavior. Each test is guaranteed to be done the same way. If we need to change the computation, it is easier to change the function than to find and change every occurrence of the equivalent expression. The function can be reused rather than rewritten for other applications. However, Calling a function is apt to be slower than evaluating the equivalent expression. On most machines, a function call does a lot of work: Registers are saved before the call and restored after the return; arguments may be copied; and the program branches to a new location. Fortunately we have a good way to fix it disadvantage. The Inline Functions A function specified as inline (usually) is expanded “in line” at each call. If function were defined as inline, then this call (probably) would be expanded during compilation into expression. inline const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2; &#125; cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; //may be compilation into expression. //cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl; In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. Function MatchingIn many (if not most) cases, it is easy to figure out which overloaded function matches a given call. However, it is not so simple when the overloaded functions have the same number of parameters and when one or more of the parameters have types that are related by conversions. The step of function matching as follow: The first step of function matching identifies the set of overloaded functions considered for the call. The functions in this set are the candidate functions. A candidate function is a function with the same name as the called function and for which a declaration is visible at the point of the call. The second step selects from the set of candidate functions those functions that can be called with the arguments in the given call. The selected functions are the viable functions. To be viable, a function must have the same number of parameters as there are arguments in the call, and the type of each argument must match—or be convertible to—the type of its corresponding parameter. The third step of function matching determines which viable function provides the best match for the call. This process looks at each argument in the call and selects the viable function (or functions) for which the corresponding parameter best matches the argument. The idea is that the closer the types of the argument and parameter are to each other, the better the match. In order to determine the best match, the compiler ranks the conversions that could be used to convert each argument to the type of its corresponding parameter. Conversions are ranked as follows: An exact match. Match through a const conversion Match through a promotion Match through an arithmetic or pointer conversion Match through a class-type conversion. Pointers to FunctionsA function pointer is just that—a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function’s type is determined by its return type and the types of its parameters. The function’s name is not part of its type. For example: // compare two int bool cmp(int a, int b) &#123; return a &gt; b; &#125; // pf points to a function returning bool that takes two int bool (*pf)(int a, int b); When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of cmp to pf as follows: pf = cmp; pf = &amp;cmp; Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly—there is no need to dereference the pointer: bool a = (*cmp)(1, 2); bool b = cmp(1, 2); bool c = (*pf)(1, 2); bool d = pf(1, 2); As usual, when we use an overloaded function, the context must make it clear which version is being used. When we declare a pointer to an overloaded function the compiler uses the type of the pointer to determine which overloaded function to use. The type of the pointer must match one of the overloaded functions exactly: void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; // ok: pf1 points to ff(unsigned int) void (*pf2)(int) = ff; // error: no ff with a matching parameter list double (*pf3)(int*) = ff; // error: return type of ff and pf3 don&#39;t match Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer: void useBigger(const string&amp; s1, const string&amp; s2, bool pf(const string&amp;, const string&amp;)); // equivalent declaration: explicitly define the parameter as a pointer to function void useBigger(const string&amp; s1, const string&amp; s2, bool (*pf)(const string&amp;, const string&amp;)); When we pass a function as an argument, we can do so directly. It will be automatically converted to a pointer. As with arrays, we can’t return a function type but can return a pointer to a function type. Similarly, we must write the return type as a pointer type; the compiler will not automatically treat a function return type as the corresponding pointer type. Also as with array returns, by far the easiest way to declare a function that returns a pointer to function is by using a type alias: using F = int(int, int); // F is a function type, not a pointer using pF = int(*)(int, int);// pF is a pointer pF f1(int); // ok: pF is a pointer to function; f1 returns a pointer to function F f2(int); // error: F is a function type; f1 can&#39;t return a function F *f3(int); // ok: explicitly specify that the return type is a pointer to function For completeness, it’s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return: auto f1(int) -&gt; int (*)(int*, int); ClassesIn C++ we use classes to define our own data types. By defining types that mirror concepts in the problems we are trying to solve, we can make our programs easier to write, debug, and modify. Defining Abstract Data TypesOur Sales_data class(in previous note) is not an abstract data type. It lets users of the class access its data members and forces users to write their own operations. To make Sales_data an abstract type, we need to define operations for users of Sales_data to use. Once Sales_data defines its own operations, we can encapsulate (that is, hide) its data members. Ultimately, we want Sales_data to support the same set of operations as the Sales_item class. The Sales_item class had one member function named isbn, and supported the +, =, +=, &lt;&lt;, and &gt;&gt; operators. We’ll learn how to define our own operators in the next post. For now, we’ll define ordinary (named) functions for these operations. Thus, the interface to Sales_data consists of the following operations: An isbn member function to return the object’s ISBN A combine member function to add one Sales_data object into another A function named add to add two Sales_data objects A read function to read data from an istream into a Sales_data object A print function to print the value of a Sales_data object on an ostream Before we think about how to implement our class, let’s look at how we can use our interface functions. As one example, we can use these functions to write a version of the bookstore program that works with Sales_data objects rather than Sales_items: #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;Sales_data.h&quot; using std::cin; using std::cout; using std::endl; int main() &#123; Sales_data total; // variable to hold the running sum if (read(cin, total)) &#123; // read the first transaction Sales_data trans; // variable to hold data for the next transaction while (read(cin, trans)) &#123; // read the remaining transactions if (total.isbn() == trans.isbn()) // check the isbns total.combine(trans); // update the running total else &#123; print(cout, total) &lt;&lt; endl; // print the results total = trans; // process the next book &#125; &#125; print(cout, total) &lt;&lt; endl; // print the last transaction &#125; else &#123; // there was no input std::cerr &lt;&lt; &quot;No data?!&quot; &lt;&lt; endl; // notify the user &#125; return 0; &#125; Our revised class will have the same data members as the version we defined in previous: bookNo, a string representing the ISBN; units_sold, an unsigned that says how many copies of the book were sold; and revenue, a double representing the total revenue for those sales. As we’ve seen, our class will also have two member functions, combine and isbn. In addition, we’ll give Sales_data another member function to return the average price at which the books were sold. This function, which we’ll name avg_price, isn’t intended for general use. It will be part of the implementation, not part of the interface. We define and declare member functions similarly to ordinary functions. Member functions must be declared inside the class. Member functions may be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, such as add, read, and print, are declared and defined outside the class. #ifndef SALES_DATA_H #define SALES_DATA_H #include &lt;string&gt; struct Sales_data &#123; // new members: operations on Sales_data objects std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; &#125;; // nonmember Sales_data interface functions Sales_data add(const Sales_data&amp;, const Sales_data&amp;); std::ostream&amp; print(std::ostream&amp;, const Sales_data&amp;); std::istream&amp; read(std::istream&amp;, Sales_data&amp;); #endif We’ll start by explaining the isbn function, which returns a string and has an empty parameter list. As with any function, the body of a member function is a block. In this case, the block contains a single return statement that returns the bookNo data member of a Sales_data object. The interesting thing about this function is how it gets the object from which to fetch the bookNo member. Let’s look again at a call to the isbn member function: total.isbn(),Here we use the dot operator to fetch the isbn member of the object named total, which we then call. When isbn refers to members ofSales_data, it is referring implicitly to the members of the object on which the function was called. In this call, when isbn returns bookNo, it is implicitly returning total.bookNo. Member functions access the object on which they were called through an extra, implicit parameter named this. When we call a member function, this is initialized with the address of the object on which the function was invoked. For example, when we call total.isbn(), the compiler passes the address of total to the implicit this parameter in isbn. It is as if the compiler rewrites this call as Sales_data::isbn(&amp;total), which calls the isbn member of Sales_data passing the address of total. The this parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named this. Inside the body of a member function, we can use this. It would be legal, although unnecessary, to define isbn as: std::string isbn() const &#123; return this-&gt;bookNo; &#125; The other important part about the isbn function is the keyword const that follows the parameter list. The purpose of that const is to modify the type of the implicit this pointer. By default, the type of this is a const pointer to the nonconst version of the class type. For example, by default, the type of this in a Sales_data member function is Sales_data *const. Although this is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind this to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object. If isbn were an ordinary function and if this were an ordinary pointer parameter, we would declare this as const Sales_data *const. After all, the body of isbn doesn’t change the object to which this points, so our function would be more flexible if this were a pointer to const. Member functions that use const in this way are const member functions. The fact that this is a pointer to const means that const member functions cannot change the object on which they are called. Thus, isbn may read but not write to the data members of the objects on which it is called. The definitions of the member functions of a class are nested inside the scope of the class itself. Hence, isbn’s use of the name bookNo is resolved as the data member defined inside Sales_data. It is worth noting that isbn can use bookNo even though bookNo is defined after isbn. Because the compiler processes classes in two steps— the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear. As with any other function, when we define a member function outside the class body, the member’s definition must match its declaration. That is, the return type, parameter list, and name must match the declaration in the class body. // define avg price function double Sales_data::avg_price() const &#123; if (units_sold) return revenue / units_sold; else return 0; &#125; The function name, Sales_data::avg_price, uses the scope operator to say that we are defining the function named avg_price that is declared in the scope of the Sales_data class. Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. Thus, when avg_price refers to revenue and units_sold, it is implicitly referring to the members of Sales_data. The combine function is intended to act like the compound assignment operator, +=. The object on which this function is called represents the left-hand operand of the assignment. The right-hand operand is passed as an explicit argument: // define combine function Sales_data&amp; Sales_data::combine(const Sales_data&amp; rhs) &#123; units_sold += rhs.units_sold; // add the members of rhs into revenue += rhs.revenue; // the members of &#39;&#39;this&#39;&#39; object return *this; // return the object on which the function was called &#125; When our transaction-processing program calls total.combine(trans);, the address of total is bound to the implicit this parameter and rhs is bound to trans. At the end, Here the return statement dereferences this to obtain the object on which the function is executing. That is, for the call above, we return a reference to total. Class authors often define auxiliary functions, such as our add, read, and print functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself. We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its definition. Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface. The read and print functions do the same job as the code in previous code: std::ostream&amp; print(std::ostream&amp; os, const Sales_data&amp; item) &#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os; &#125; std::istream&amp; read(std::istream&amp; is, Sales_data&amp; item) &#123; double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = item.units_sold * price; return is; &#125; The add function takes two Sales_data objects and returns a new Sales_data representing their sum: Sales_data add(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123; Sales_data sum = lhs; sum.combine(rhs); return sum; &#125; Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more special member functions known as constructors. The job of a constructor is to initialize the data members of a class object. A constructor is run whenever an object of a class type is created. Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function, the constructors must differ from each other in the number or types of their parameters. Our Sales_data class does not define any constructors, yet the programs we’ve written that use Sales_data objects compile and run correctly. So, How are they initialized? The answer is if our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us. For our Sales_data class we’ll define four constructors with the following parameters: An istream&amp; from which to read a transaction. A const string&amp; representing an ISBN, an unsigned representing the count of how many books were sold, and a double representing the price at which the books sold. A const string&amp; representing an ISBN. This constructor will use default values for the other members. An empty parameter list (i.e., the default constructor) which as we’ve just seen we must define because we have defined other constructors. // constructors added // means default constructor Sales_data() = default; Sales_data(std::string&amp; s) : bookNo(s) &#123;&#125; Sales_data(std::string&amp; s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p* n) &#123;&#125; Sales_data(std::istream&amp;); It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty. Unlike our other constructors, the constructor that takes an istream does have work to do. Inside its function body, this constructor calls read to give the data members new values: Sales_data::Sales_data(std::istream&amp; is) &#123; read(is, *this); &#125; There are something need to notice: As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the constructor is a member. In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed. Access Control and EncapsulationAt this point, we have defined an interface for our class; but nothing forces users to use that interface. Our class is not yet encapsulated—users can reach inside a Sales_data object and meddle with its implementation. In C++ we use access specifiers to enforce encapsulation: Members defined after a public specifier are accessible to all parts of the program. The public members define the interface to the class. Members defined after a private specifier are accessible to the member functions of the class but are not accessible to code that uses the class. struct Sales_data &#123; public: // constructors added Sales_data() = default; Sales_data(std::string&amp; s) : bookNo(s) &#123;&#125; Sales_data(std::string&amp; s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p* n) &#123;&#125; Sales_data(std::istream&amp;); // new members: operations on Sales_data objects std::string isbn() const; Sales_data&amp; combine(const Sales_data&amp;); private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; &#125;; A class may contain zero or more access specifiers, and there are no restrictions on how often an access specifier may appear. Each access specifier specifies the access level of the succeeding members. The specified access level remains in effect until the next access specifier or the end of the class body. We also made another, more subtle, change: We used the class keyword rather than struct to open the class definition. This change is strictly stylistic; we can define a class type using either keyword. The only difference between struct and class is the default access level. A class may define members before the first access specifier. Access to such members depends on how the class is defined. If we use the struct keyword, the members defined before the first access specifier are public; if we use class, then the members are private. Now that the data members of Sales_data are private, our read, print, and add functions will no longer compile. The problem is that although these functions are part of the Sales_data interface, they are not members of the class. A class can allow another class or function to access its nonpublic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend: // add into class friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::ostream&amp; print(std::ostream&amp;, const Sales_data&amp;); friend std::istream&amp; read(std::istream&amp;, Sales_data&amp;); Encapsulation provides two important advantages: User code cannot inadvertently corrupt the state of an encapsulated object. The implementation of an encapsulated class can change over time without requiring changes in user-level code. Additional Class FeaturesThe Sales_data class is pretty simple, in the next we’ll cover some additional class-related features that Sales_data doesn’t need to use. These features include type members, in-class initializers for members of class type, mutable data members, inline member functions, returning *this from a member function, more about how we define and use class types, and class friendship. First we will talk about type members, suppose we want use a class called Screen represents a window on a display. Each Screen has a string member that holds the Screen’s contents, and three string::size_type members that represent the position of the cursor, and the height and width of the screen. In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private: class Screen &#123; public: using pos = std::string::size_type; private: std::string contents; pos height; pos height; pos cursor; &#125;; We defined pos in the public part of Screen because we want users to use that name. we can use Screen::pos k = 10; after include header file. #ifndef Screen_H #define Screen_H #include &lt;string&gt; class Screen &#123; public: using pos = std::string::size_type; // default constructor and another constructor Screen() = default; Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht* wd, c) &#123;&#125; // get the character at the cursor // implicitly inline char get() const &#123; return contents[cursor]; &#125; // explicitly inline inline char get(pos r, pos c) const &#123; pos row = r * width; return contents[row + c]; &#125; // move cursor position Screen&amp; move(pos r, pos c) &#123; pos row = r * width; cursor = row + c; return *this; &#125; // test void test_mutable() const &#123; ++access_ctr; &#125; private: mutable pos access_ctr = 0; std::string contents; pos height = 0; pos width = 0; pos cursor = 0; &#125;; #endif // !Screen_H Classes often have small functions that can benefit from being inlined. Member functions defined inside the class are automatically inline. As with nonmember functions, member functions may be overloaded so long as the functions differ by the number and/or types of parameters. In the screen class, the second get function is a overload function. Screen::pos h = 10; Screen::pos w = 10; Screen myscreen(h,w,&#39;A&#39;); cout &lt;&lt; myscreen.get(0,0) &lt;&lt; endl; cout &lt;&lt; myscreen.get() &lt;&lt; endl; It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a const member function. We indicate such members by including the mutable keyword in their declaration. A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member. As an example, we’ll give Screen a mutable member named access_ctr, and a const member function that change the value of mutable member. The function can be correct use. Next we’ll add functions to set the character at the cursor or at a given location: #ifndef Screen_H #define Screen_H #include &lt;string&gt; class Screen &#123; public: // other members function as before //set char in screen Screen&amp; set(char c) &#123; contents[cursor] = c; return *this; &#125; Screen&amp; set(pos r, pos col, char c) &#123; contents[r * width + col] = c; return *this; &#125; // other members as before &#125;; #endif // !Screen_H Like the move operation, our set members return a reference to the object on which they are called. Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression: myscreen.move(4, 0).set(&#39;B&#39;); That is, this statement is equivalent to: myscreen.move(4, 0); myscreen.set(&#39;B&#39;); Next, we’ll add an operation, which we’ll name display, to print the contents of the Screen. We’d like to be able to include this operation in a sequence of set and move operations. Therefore, like set and move, our display function will return a reference to the object on which it executes. Logically, displaying a Screen doesn’t change the object, so we should make display a const member. If display is a const member, then this is a pointer to const and *this is a const object. Hence, the return type of display must be const Sales_data&amp;. However, if display returns a reference to const, we won’t be able to embed display into a series of actions: myScreen.display(std::cout).set(&#39;B&#39;); We can overload a member function based on whether it is const for the same reasons that we can overload a function based on whether a pointer parameter points to const. The nonconst version will not be viable for const objects; we can only call const member functions on a const object. We can call either version on a nonconst object, but the nonconst version will be a better match. public: //print screen const Screen&amp; print(std::ostream&amp; os)const &#123; do_display(os); return *this; &#125; Screen&amp; print(std::ostream&amp; os) &#123; do_display(os); return *this; &#125; private: void do_display(std::ostream&amp; os) const &#123; for (size_t i = 0; i &lt; height; i++) &#123; for (size_t j = 0; j &lt; width; j++) &#123; os &lt;&lt; get(i, j); &#125; os &lt;&lt; std::endl; &#125; &#125; Our Sales_data class defined three ordinary nonmember functions as friends. A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In addition, a friend function can be defined inside the class body. Such functions are implicitly inline. For example, we want use a class called Windows_mgr to control a set of screen, such as clear screen. To do this job, our function called clear needs to access the private data members of Screen. To allow this access, Screen can designate Window_mgr as its friend: class Screen &#123; // Window_mgr members can access the private parts of class Screen friend class Windows_mgr; // ... rest of the Screen class &#125;; class Windows_mgr &#123; public: using ScreenIndex = std::vector&lt;Screen&gt;::size_type; Windows_mgr() = default; // clear screen void clear(ScreenIndex i) &#123; Screen&amp; s = screens[i]; s.contents = std::string(s.width * s.height, &#39; &#39;); &#125; private: std::vector&lt;Screen&gt; screens&#123; Screen(10,10,&#39; &#39;) &#125;; &#125;; Rather than making the entire Window_mgr class a friend, Screen can instead specify that only the clear member is allowed access. When we declare a member function to be a friend, we must specify the class of which that function is a member: class Screen &#123; // clear function in Windoes_mgr can access the private parts of class Screen friend void Windows_mgr::clear(ScreenIndex i); // ... rest of the Screen class &#125;; Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions. In this example, we must order our program as follows: First, define the Window_mgr class, which declares, but cannot define, clear. Screen must be declared before clear can use the members of Screen. Next, define class Screen, including a friend declaration for clear. Finally, define clear, which can now refer to the members in Screen. The full code: #ifndef Screen_H #define Screen_H #include &lt;string&gt; #include &lt;vector&gt; class Screen; class Windows_mgr &#123; public: using ScreenIndex = std::vector&lt;Screen&gt;::size_type; Windows_mgr() = default; // clear screen void clear(ScreenIndex i); // add a new screen void add(); private: std::vector&lt;Screen&gt; screens; &#125;; class Screen &#123; public: friend void Windows_mgr::clear(ScreenIndex i); using pos = std::string::size_type; // default constructor and another constructor Screen() = default; Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht* wd, c) &#123;&#125; // get the character at the cursor // implicitly inline char get() const &#123; return contents[cursor]; &#125; // explicitly inline inline char get(pos r, pos c) const &#123; pos row = r * width; return contents[row + c]; &#125; // move cursor position Screen&amp; move(pos r, pos c) &#123; pos row = r * width; cursor = row + c; return *this; &#125; // test mutable mumber void test_mutable() const &#123; ++access_ctr; &#125; //set char in screen Screen&amp; set(char c) &#123; contents[cursor] = c; return *this; &#125; Screen&amp; set(pos r, pos col, char c) &#123; contents[r * width + col] = c; return *this; &#125; //print screen const Screen&amp; print(std::ostream&amp; os)const &#123; do_display(os); return *this; &#125; Screen&amp; print(std::ostream&amp; os) &#123; do_display(os); return *this; &#125; private: mutable pos access_ctr = 0; std::string contents; pos height = 0; pos width = 0; pos cursor = 0; void do_display(std::ostream&amp; os) const &#123; for (size_t i = 0; i &lt; height; i++) &#123; for (size_t j = 0; j &lt; width; j++) &#123; os &lt;&lt; get(i, j); &#125; os &lt;&lt; &#39;\\n&#39;; &#125; &#125; &#125;; void Windows_mgr::clear(ScreenIndex i) &#123; Screen&amp; s = screens[i]; s.contents = std::string(s.width * s.height, &#39; &#39;); &#125; void Windows_mgr::add() &#123; Screen new_s(10, 10, &#39; &#39;); screens.push_back(new_s); &#125; #endif // !Screen_H Class ScopeIn the programs we’ve written so far, name lookup (the process of finding which declarations match the use of a name) has been relatively straightforward: First, look for a declaration of the name in the block in which the name was used. Only names declared before the use are considered. If the name isn’t found, look in the enclosing scope(s). If no declaration is found, then the program is in error. The way names are resolved inside member functions defined inside the class may seem to behave differently than these lookup rules. However, in this case, appearances are deceiving. Class definitions are processed in two phases: First, the member declarations are compiled. Function bodies are compiled only after the entire class has been seen. Because member function bodies are not processed until the entire class is seen, they can use any name defined inside the class. If function definitions were processed at the same time as the member declarations, then we would have to order the member functions so that they referred only to names already seen. Constructors RevisitedConstructors are a crucial part of any C++ class. In this section we’ll cover some additional capabilities of constructors, and deepen our coverage of the material introduced earlier. When we define variables, we typically initialize them immediately rather than defining them and then assigning to them, exactly the same distinction between initialization and assignment applies to the datamembers of objects. If we do not explicitly initialize a member in the constructor initializer list, that member is default initialized before the constructor body starts executing. For example: // legal but sloppier way to write the Sales_data constructor: no constructor initializers Sales_data::Sales_data(const string&amp; s, unsigned cnt, double price) &#123; bookNo = s; units_sold = cnt; revenue = cnt * price; &#125; This version and our original definition in previous have the same effect: When the constructor finishes, the data members will hold the same values. The difference is that the original version initializes its data members, whereas this version assigns values to the data members. How significant this distinction is depends on the type of the data member. We can often, but not always, ignore the distinction between whether a member is initialized or assigned. Members that are const or references must be initialized. #pragma once class test &#123; public: //ok: test(int n) : a(n) &#123;&#125; //error: test(int n)&#123; a = n; &#125; private: const int a; &#125;; By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize const or reference data members is in the constructor initializer. Another need notice in c++ is Order of Member Initialization, Members are initialized in the order in which they appear in the class definition: The first member is initialized first, then the next, and so on. The order in which initializers appear in the constructor initializer list does not change the order of initialization. The order of initialization often doesn’t matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important. We can set default arguments in constructors: test(int n = 10) : a(n) &#123;&#125; The new standard extends the use of constructor initializers to let us define so-called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to “delegate” some (or all) of its work to this other constructor. As an example, we’ll rewrite the Sales_data class to use delegating constructors as follows: class Sales_data &#123; public: // nondelegating constructor initializes members from corresponding arguments Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt* price) &#123; &#125; // remaining constructors all delegate to another constructor Sales_data() : Sales_data(&quot;&quot;, 0, 0) &#123;&#125; Sales_data(std::string s) : Sales_data(s, 0, 0) &#123;&#125; Sales_data(std::istream&amp; is) : Sales_data() &#123; read(is, *this); &#125; // other members as before &#125;; static Class MembersClasses sometimes need members that are associated with the class, rather than with individual objects of the class type. We say a member is associated with the class by adding the keyword static to its declaration. Like any other member, static members can be public or private. The type of a static data member can be const, reference, array, class type, and so forth. As an example, we’ll define a class to represent an account record at a bank: #ifndef Account_H #define Account_H #include &lt;string&gt; class Account &#123; public: Account() = default; static double get_rate() &#123; return rate; &#125; static void set_rate(double r) &#123; rate = r; &#125; private: std::string user; double amount; static double rate; &#125;; //define static member double Account::rate = 0.001; #endif The static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two data members—user and amount. There is only one rate object that will be shared by all the Account objects. How could we use a class static member? First, we can directly through the scope operator: double r; r = Account::get_rate(); // access a static member using the scope operator Even though static members are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a static member: Account s; double r; r = s.get_rate(); Member functions can use static members directly, without the scope operator. As with any other member function, we can define a static member function inside or outside of the class body. When we define a static member outside the class, we do not repeat the static keyword. The keyword appears only with the declaration inside the class body. Because static data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class’ constructors. Moreover, in general, we may not initialize a static member inside the class. Instead, we must define and initialize each static data member outside the class body. Like any other object, a static data member may be defined only once.","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch2) C++ Basic Features - Type","slug":"c++ c2","date":"2021-12-19T13:52:45.000Z","updated":"2023-04-21T08:44:55.709Z","comments":true,"path":"2021/12/19/c++ c2/","link":"","permalink":"https://noahbishop.github.io/2021/12/19/c++%20c2/","excerpt":"","text":"C++ Basic Features - TypeEvery widely used programming language provides a common set of features, which differ in detail from one language to another, this post briefly show the basic feature. Variables and basic typeType are fundamental to every programming language: the tell us what the data mean and what operations we can perform on those data. Primitive Built-in TypesC++ defines a set of Primitive Built-in Types that include arithmetic types and a special type called void, the arithmetic types represent character, integer, boolean values, floating-point numbers. The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value. This table give the normally used types and details. type meaning size int integer 32 bits long long long integer 64 bits float single-precision-floating 32 bits double double-precision-floating 64 bits long double extended-precision-floating 128 bits char character 8 bits bool Boolean 8 bits #include &lt;iostream&gt; int main() &#123; //you can use this statement check how many bytes for the type //change int to another type you want std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; return 0; &#125; The type of an object defines the data that an object might contain and what operations that object can perform. Among the operations that many types support is the ability to convert objects of the given type to other, related types. Type conversions happen automatically when we use an object of one type where an object of another type is expected. #include &lt;iostream&gt; int main() &#123; //only b = 0 can&#39;t make b is false bool b = 10; // b is true //actually, true equal to 1 and false equal to 0 int i = b; // i has value 1 //the fractional part will be lose i = 3.14; // i has value 3 double pi = i; // pi has value 3.0 unsigned char c = -1; // assuming 8-bit chars, c has value 255 signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined unsigned u = 10; int i = -42; //the type of sum result is int std::cout &lt;&lt; i + i &lt;&lt; std::endl; // prints -84 //the type of sum result is unsigned //the int tpye has been convert to a unsigned before add operation std::cout &lt;&lt; u + i &lt;&lt; std::endl; // if 32-bit ints, prints 4294967264 return 0; &#125; VariablesA variable provides us with named storage that our programs can manipulate. Each variable in C++ has a type. The type determines the size and layout of the variable’s memory, the range of values that can be stored within that memory, and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as “variables” or “objects” interchangeably. The previous codes has explained how define a variable, but they are initialized, if you define a variable without an initializer, what that default value is depends on the type of the variable and may also depend on where the variable is defined. Some classes require that every object be explicitly initialized. The compiler will complain if we try to create an object of such a class with no initializer. The another notice is the difference between variable declarations and definitions. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently. When we separate a program into multiple files, we need a way to share code across those files. A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value. //extern keyword extern int i; // declares but does not define i int j; // declares and defines j extern double pi = 3.1416; // this is a error statement Identifiers in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct, The standard also reserves a set of names for use in the standard library. The identifiers we define in our own programs may not contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an uppercase letter. In addition, identifiers defined outside a function may not begin with an underscore. Conventions for Variable Names: An identifier should give some indication of its meaning Variable names normally are lowercase classes we define usually begin with an uppercase letter Identifiers with multiple words should visually distinguish each word, for example, student_loan or studentLoan A scope is a part of the program in which a name has a particular meaning. Most scopes in C++ are delimited by curly braces. The same name can refer to different entities in different scopes. Names are visible from the point where they are declared until the end of the scope in which the declaration appears. #include &lt;iostream&gt; //The name main is defined outside any curly braces //names defined outside a function has global scope int a = 0; int main() &#123; int sum = 0; // sum values from 1 through 10 inclusive for (int val = 1; val &lt;= 10; ++val) sum += val; // equivalent to sum = sum + val std::cout &lt;&lt; &quot;Sum of 1 to 10 inclusive is &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; &#125; Scopes can contain other scopes. The contained (or nested) scope is referred to as an inner scope, the containing scope is the outer scope. Once a name has been declared in a scope, that name can be used by scopes nested inside that scope. Names declared in the outer scope can also be redefined in an inner scope, this is a simple case. #include &lt;iostream&gt; // Program for illustration purposes only: It is bad style for a function // to use a global variable and also define a local variable with the same name int reused = 42; // reused has global scope int main() &#123; int unique = 0; // unique has block scope // output #1: uses global reused; prints 42 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; int reused = 0; // new, local object named reused hides global reused // output #2: uses local reused; prints 0 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; // output #3: explicitly requests the global reused; prints 42 0 std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; return 0; &#125; Compound TypesA compound type is a type that is defined in terms of another type. C++ has several compound types, two of which—references and pointers—we’ll cover in this chapter. A reference defines an alternative name for an object. A reference type “refers to” another type. We define a reference type by writing a declarator of the form &amp;d, where d is the name being declared: Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference, references must be initialized. #include &lt;iostream&gt; int main() &#123; int ival = 1024; int&amp; refVal = ival; // refVal refers to (is another name for) ival refVal = 100; std::cout &lt;&lt; ival &lt;&lt; &quot; &quot; &lt;&lt; refVal &lt;&lt; std::endl; // will print 100 100 //error statement examples int &amp;refVal2; // error: a reference must be initialized int &amp;refVal4 = 10; // error: initializer must be an object double dval = 3.14; int &amp;refVal5 = dval; // error: initializer must be an int object return 0; &#125; A pointer is a compound type that “points to” another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized. the next case show how to use pointer: #include &lt;iostream&gt; int main() &#123; // create a empty pointer int* ptr = nullptr; // ptrToN holds the address of n; ptrToN is a pointer to n //We get the address of an object by usin the address of operator //(the &amp; operator) //note this is different from the reference int n = 10; int* ptrToN = &amp;n; //print the address of n and value std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; ptrToN &lt;&lt; &quot; value: &quot; &lt;&lt; *ptrToN &lt;&lt; std::endl; //cahnge value of n by pointer, will print 100 *ptrToN = 100; std::cout &lt;&lt; n &lt;&lt; std::endl; //point to pointer int ival = 1024; int *pi = &amp;ival; // pi points to an int int **ppi = &amp;pi; // ppi points to a pointer to an int return 0; &#125; (notice: Because references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference.) The type void* is a special pointer type that can hold the address of any object. Like any other pointer, a void pointer holds an address, but the type of the object at that address is unknown, so we cannot use a voidto operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object. Generally, we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. const QualifierSometimes we want to define a variable whose value we know cannot be changed. We can make a variable unchangeable by defining the variable’s type as const. Because we can’t change the value of a const object after we create it, it must be initialized. const int n = 512; n = 1024; // error: attempt to write to const object const int k; //error: k is uninitialized const Sometimes we have a const variable that we want to share across multiple files, to share a const object among multiple files, you must define the variable as extern. As with any other object, we can bind a reference to an object of a const type. To do so we use a reference to const, which is a reference that refers to a const type. Unlike an ordinary reference, a reference to const cannot be used to change the object to which the reference is bound: const int ci = 1024; const int &amp;r1 = ci; // ok: both reference and underlying object are const int &amp;r2 = ci; // error: non const reference to a const object we noted that there are two exceptions to the rule that the type of a reference must match the type of the object to which it refers. //this code can be compilation double dval = 3.14; const int &amp;ri = dval; //actually const int &amp;ri = dval; will be think as this //const int temp = dval; // create a temporary const int from the double //const int &amp;ri = temp; //const int &amp;ri = temp; As with references, we can define pointers that point to either const or nonconst types. Like a reference to const, a pointer to const may not be used to change the object to which the pointer points. Next case show details. const double pi = 3.14; // pi is const; its value may not be changed double *ptr = &amp;pi; // error: ptr is a plain pointer const double *cptr = &amp;pi; // ok: cptr may point to a double that is const *cptr = 42; // error: cannot assign to *cptr double dval = 3.14; // dval is a double; its value can be changed cptr = &amp;dval; // ok: but can&#39;t change dval through cptr *cptr = 5472; // error: cannot assign to *cptr Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. Like any other const object, a const pointer must be initialized, and once initialized, its value (i.e., the address that it holds) may not be changed. int errNumb = 0; int* const curErr = &amp;errNumb; // curErr will always point to errNumb const double pi = 3.14159; const double* const pip = &amp;pi; // pip is a const pointer to a const object We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. Dealing with TypesA type alias is a name that is a synonym for another type. Type aliases let us simplify complicated type definitions, making those types easier to use. We can define a type alias in one of two ways. Traditionally, we use a typedef, the new standard introduced a second way to define a type alias, via an aliasdeclaration: typedef long long ll; // ll is a synonym for long long typedef long long *ptr; // ptr for long long* using ll = long long; // ll is a synonym for long long Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. As with any other type specifier, we can define multiple variables using auto. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other: int n1 = 10, n2 = 20; double n3 = 3.5, n4 = 9.5; //type of item from the type returned by applying + to val1 and val2. auto s1 = n1 + n3; // s1&#39;s type is double auto s2 = n1 + n2; // s2;s type is int auto k1 = 10, k3 = 19; // ok auto k2 = 10, *k4 = &amp;k2; // ok //error C++ &#39;auto&#39; type is for this entity, but was previously implied to be int auto k5 = 10, k6 = 3.14; Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand. const double m = 90.99, &amp;r = m, * p = &amp;m; decltype(m) ap = 184; // ap has type const int decltype(r) x = m; // x has type const int&amp; and is bound to x decltype(m) y; // error: y is a const and must be initialized decltype(r) z; // error: z is a reference and must be initialized decltype(*p) c; // error: c is int&amp; and must be initialized // decltype of a parenthesized variable is always a reference decltype((m)) d; // error: d is double&amp; and must be initialized decltype(m) e; // ok: e is an (uninitialized) double Defining Our Own Data StructuresIn C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes, we will tell how to defined a full class in next several chapters, first we create a class that does not support any operations. struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; &#125;; Our class begins with the keyword struct, followed by the name of the class and a (possibly empty) class body. The class body is surrounded by curly braces and forms a new scope. The names defined inside the class must be unique within the class but can reuse names defined outside the class. The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body: struct Sales_data &#123; /* ... */ &#125; accum, trans, *salesptr; // equivalent, but better way to define these objects struct Sales_data &#123; /* ... */ &#125;; Sales_data accum, trans, *salesptr; Generally, we define a class in a separate header file, typically, classes are stored in headers whose name derives from the name of the class. Headers often need to use facilities from other headers. For example,because our Sales_data class has a string member, Sales_data.h must #include the string header. As we’ve seen, programs that use Sales_data also need to include the string header in order to use the bookNo member. As a result, programs that use Sales_data will include the string header twice: once directly and once as a side effect of including Sales_data.h. Because a header might be included more than once, we need to write our headers in a way that is safe even if the header is included multiple times. The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header. C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif. //Sales_data.h #ifndef SALES_DATA_H #define SALES_DATA_H #include &lt;string&gt; struct Sales_data &#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; &#125;; #endif The first time Sales_data.h is included, the #ifndef test will succeed. The preprocessor will process the lines following #ifndef up to the #endif. As a result, the preprocessor variable SALES_DATA_H will be defined and the contents of Sales_data.h will be copied into our program. If we include Sales_data.h later on in the same file, the #ifndef directive will be false. The lines between it and the #endif directive will be ignored. this is a simple case to statistics sales of book: #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;Sales_data.h&quot; int main() &#123; Sales_data book1, book2; double price = 0; // read the first transactions: ISBN, number of books sold, price per book std::cin &gt;&gt; book1.bookNo &gt;&gt; book1.units_sold &gt;&gt; price; book1.revenue = price * book1.units_sold; // read the second transactions: ISBN, number of books sold, price per book std::cin &gt;&gt; book2.bookNo &gt;&gt; book2.units_sold &gt;&gt; price; book2.revenue = price * book2.units_sold; //add operation if (book1.bookNo == book2.bookNo) &#123; unsigned totalCnt = book1.units_sold + book2.units_sold; double totalRevenue = book1.revenue + book2.revenue; // print: ISBN, total sold, total revenue, average price per book std::cout &lt;&lt; book1.bookNo &lt;&lt; &quot; &quot; &lt;&lt; totalCnt &lt;&lt; &quot; &quot; &lt;&lt; totalRevenue &lt;&lt; &quot; &quot;; if (totalCnt != 0) std::cout &lt;&lt; totalRevenue / totalCnt &lt;&lt; std::endl; else std::cout &lt;&lt; &quot;(no sales)&quot; &lt;&lt; std::endl; return 0; &#125; else &#123; std::cout &lt;&lt; &quot;there are different books&quot; &lt;&lt; std::endl; return -1; &#125; &#125; Strings, Vectors, and ArraysIn addition to the built-in types covered in previous, C++ defines a rich library of abstract data types. Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections. Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector. Before beginning our exploration of the library types, we’ll look at a mechanism for simplifying access to the names defined in the library. Namespace using DeclarationsUp to now, our programs have explicitly indicated that each library name we use is in the std namespace. For example, to read from the standard input, we write std::cin. std::cin says that we want to use the name cin from the namespace std. there are easier ways to use namespace members. The safest way is a using declaration. #include &lt;iostream&gt; // using declaration; when we use the name cin, we get the one from the namespacestd using std::cin; int main() &#123; int i; cin &gt;&gt; i; // ok: cin is a synonym for std::cin cout &lt;&lt; i; // error: no using declaration; we must use the full name std::cout &lt;&lt; i; // ok: explicitly use cout from namepsace std return 0; &#125; Note “Headers Should Not Include using Declarations”, The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. Library string TypeEach class defines how objects of its type can be initialized. A class may define many different ways to initialize objects of its type. examples: #include &lt;iostream&gt; #include &lt;string&gt; using std::string; int main() &#123; string s1; // default initialization; s1 is the empty string string s2 = s1; // s2 is a copy of s1 string s3 = &quot;hello&quot;;// s3 is a copy of the string literal string s4(10, &#39;A&#39;); // s4 is AAAAAAAAAA string s5(s1); // s5 is a copy of s1 string s6(&quot;hello&quot;); // s6 is a copy of the string literal return 0; &#125; When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization. string s5 = &quot;hiya&quot;; // copy initialization string s6(&quot;hiya&quot;); // direct initialization string s7(10, &#39;c&#39;); // direct initialization; s7 is cccccccccc Along with defining how objects are created and initialized, a class also defines the operations that objects of the class type can perform. The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered. which mean when we read a string containing whitespace will cause error. we can use the getline function instead of the &gt;&gt; operator. The getline function takes an input stream and a string. //input operations and output operations string str; //initlize a empty string cin &gt;&gt; str; //read from istream cout &lt;&lt; str &lt;&lt; endl; //write to output getline(cin, str); //read a line cout &lt;&lt; str &lt;&lt; endl; //write to output Sometimes we want get the information of string, such as if empty and the size of string, The empty function does what one would expect: It returns a bool indicating whether the string is empty. The size member returns the length of a string. It might be logical to expect that size returns an int or unsigned. Instead, size returns a string::size_type value.The string class—and most other library types—defines several companion types.These companion types make it possible to use the library types in a machine independent manner. The type size_type is one of these companion types. To use the size_type defined by string, we use the scope operator to say that the name size_type is defined in the string class. Admittedly, it can be tedious to type string::size_type. Under the new standard, we can ask the compiler to provide the appropriate type by using auto or decltype auto emp = str.empty(); //check empty auto len = str.size(); //get size The string class defines several operators that compare strings. These operators work by comparing the characters of the strings. The comparisons are case sensitive, uppercase and lowercase versions of a letter are different characters. // all compare operation cout &lt;&lt; (str1 == str2) &lt;&lt; endl; cout &lt;&lt; (str1 != str2) &lt;&lt; endl; cout &lt;&lt; (str1 &gt;= str2) &lt;&lt; endl; cout &lt;&lt; (str1 &lt;= str2) &lt;&lt; endl; cout &lt;&lt; (str1 &gt; str2) &lt;&lt; endl; cout &lt;&lt; (str1 &lt; str2) &lt;&lt; endl; //Adding Two strings string s1 = &quot;hello, &quot;, s2 = &quot;world\\n&quot;; string s3 = s1 + s2; // s3 is hello, world\\n s1 += s2; // equivalent to s1 = s1 + s2 //Adding Literals strings and strings string s1 = &quot;hello&quot;, s2 = &quot;world&quot;; string s3 = s1 + &quot;, &quot; + s2 + &#39;\\n&#39;; // ok string s4 = s1 + &quot;, &quot;; // ok: adding a string and a literal string s5 = &quot;hello&quot; + &quot;, &quot;; // error: no string operand string s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand string s7 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can&#39;t add string literals For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings. Often we need to deal with the individual characters in a string. We might want to check to see whether a string contains any whitespace, or to change the characters to lowercase, or to see whether a given character is present, and so on. The one part of processing characters is knowing and/or changing the characteristics of a character. This part of the job is handled by a set of library functions, described in next Table. These functions are defined in the cctype header. function name meanning isalnum Check if character is alphanumeric isalpha Check if character is alphabetic isblank Check if character is blank iscntrl Check if character is a control character isdigit Check if character is decimal digit isgraph Check if character has graphical representation islower Check if character is lowercase letter isprint Check if character is printable ispunct Check if character is a punctuation character isspace Check if character is a white-space isupper Check if character is uppercase letter isxdigit Check if character is hexadecimal digit tolower Convert uppercase letter to lowercase toupper Convert lowercase letter to uppercase Another of this kind of processing involves how we gain access to the characters themselves. Sometimes we need to process every character. Other times we need to process only a specific character, or we can stop processing once some condition is met. If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: the range for statement. string str = &quot;hello!!!&quot;; for (auto c : str) &#123; // for every char in str cout &lt;&lt; c &lt;&lt; endl; // print the current character followed by a newline &#125; //count the number of punctuation decltype(str.size()) punct = 0; for (auto c : str) &#123; if (ispunct(c))&#123; // if the character is punctuation ++punct; &#125; &#125; cout &lt;&lt; punct &lt;&lt; endl; If we want to change the value of the characters in a string, we must define the loop variable as a reference type, Remember that a reference is just another name for a given object. string str = &quot;hello!!!&quot;; for (auto &amp;c : str) &#123; c = toupper(c); // c is a reference, so the assignment changes the char in str &#125; cout &lt;&lt; str &lt;&lt; endl; A range for works well when we need to process every character. However, sometimes we need to access only a single character or to access characters until some condition is reached. There are two ways to access individual characters in a string: We can use a subscript or an iterator. The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. Subscripts for strings start at zero, so str[0] is the first character, and the last character is in str[str.size() - 1]. we can rewrite previous as this: for (decltype(str.size()) i = 0; i &lt; str.size(); i++) &#123; str[i] = toupper(str[i]); &#125; cout &lt;&lt; str &lt;&lt; endl; When we use a subscript, we must ensure that the subscript is in range. That is, the subscript must be &gt;= 0 and &lt; the size() of the string. One way to simplify code that uses subscripts is always to use a variable of type string::size_type as the subscript. Because that type is unsigned, we ensure that the subscript cannot be less than zero. Library vector TypeA vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. A vector is often referred to as a container because it “contains” other objects. A vector is a class template. C++ has both class and function templates. Writing a template requires a fairly deep understanding of C++. Indeed, we won’t see how to create our own templates now! Fortunately, we can use templates without knowing how to write them. For a class template, we specify which class to instantiate by supplying additional information, the nature of which depends on the template. How we specify the information is always the same: We supply it inside a pair of angle brackets following the template’s name. Note vector is a template, not a type. Types generated from vector must include the element type, for example, vector&lt;int&gt;. #include &lt;string&gt; #include &lt;vector&gt; using std::string; using std::vector; int main() &#123; vector&lt;int&gt; ivec; //ivec holds objects of type int vector&lt;vector&lt;string&gt;&gt; strvec;//strvec holds objects of type vector&lt;string&gt; return 0; &#125; As with any class type, the vector template controls how we define and initialize vectors. Next code lists the most common ways to define vectors. #include &lt;vector&gt; using std::vector; int main() &#123; vector&lt;int&gt; ivec1; //default initlization, ivec1 is empty vector&lt;int&gt; ivec2 = ivec1; //ivec2 is copy of ivec1 vector&lt;int&gt; ivec3(ivec1); //ivec3 is copy of ivec1 vector&lt;int&gt; ivec4(5, 1); //ivec4 have 5 element with value 1 vector&lt;int&gt; ivec5(5); //ivec5 have 5 element with value initliazated vector&lt;int&gt; ivec6&#123; 1,2,3,4,5 &#125;; //ivec6 have 1,2,3,4,5 vector&lt;int&gt; ivec7 = &#123; 1,2,3,4,5 &#125;;//ivec7 have 1,2,3,4,5 return 0; &#125; When we use parentheses, we are saying that the values we supply are to be used to construct the object. Thus, ivec4 and ivec5 use their initializers to determine the vector’s size, and its size and element values, respectively. When we use curly braces, {…}, we’re saying that, if possible, we want to list initialize the object. That is, if there is a way to use the values inside the curly braces as a list of element initializers, the class will do so. Only if it is not possible to list initialize the object will the other ways to initialize the object be considered. vector&lt;string&gt; ivec8&#123;10, &quot;hi&quot;&#125;; // ivec8 has ten elements with value &quot;hi&quot; vector&lt;string&gt; ivec9&#123;10&#125;; // ivec9 has ten default-initialized elements Directly initializing the element of a vector just feasible only if we have a small number of known initial values or we want make a copy of a vector. More commonly, we use the push_back method add elements when running. The push_back operation takes a value and “pushes” that value as a new lastelement onto the “back” of the vector. This code will add 0 to 99 to a vector in sequence: vector&lt;int&gt; ivec1; //default initlization, ivec1 is empty for (int i = 0; i &lt; 100; i++)&#123; ivec1.push_back(i); // add to ivec1 &#125; The standard requires that vector implementations can efficiently add elements at run time. Because vectors grow efficiently, it is often unnecessary and can result in poorer performance to define a vector of a specific size. Note we cannot use a range for if the body of the loop adds elements to the vector. The body of a range for must not change the size of the sequence over which it is iterating. In addition to push_back, vector provides only a few other operations, most of which are similar to the corresponding operations on strings. we can get full operations in here. We access the elements of a vector the same way that we access the characters in a string: vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9&#125;; for (auto &amp;i : v) // for each element in v (note: i is a reference) i *= i; // square the element value for (auto i : v) // for each element in v cout &lt;&lt; i &lt;&lt; &quot; &quot;; // print the element cout &lt;&lt; endl; The empty and size members behave as do the corresponding string members: empty returns a bool indicating whether the vector has any elements, and size returns the number of elements in the vector. The size member returns a value of the size_type defined by the corresponding vector type. //note vector is only a template vector&lt;int&gt;::size_type // ok vector::size_type // error Programmers new to C++ sometimes think that subscripting a vector adds elements; it does not. The following code intends to add ten elements to ivec: vector&lt;int&gt; ivec; // empty vector for (decltype(ivec.size()) ix = 0; ix != 10; ++ix) ivec[ix] = ix; // disaster: ivec has no elements However, it is in error: ivec is an empty vector; there are no elements to subscript! As we’ve seen, the right way to write this loop is to use push_back like previous. Introducing IteratorsAlthough we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism—known as iterators—that we can use for the same purpose. All of the library containers have iterators, but only a few of them support the subscript operator. Like pointers, iterators give us indirect access to an object. We can use an iterator to fetch an element and iterators have operations to move from one element to another. As with pointers, an iterator may be valid or invalid. A valid iterator either denotes an element or denotes a position one past the last element in a container. All other iterator values are invalid. Unlike pointers, we do not use the address-of operator to obtain an iterator. Instead, types that have iterators have members that return iterators. This code show getting vector iterators. vector&lt;int&gt; v; //In general, we do not care about the precise type that an iterator has. //In this example, we used auto to define b and e auto b = v.begin(), e = v.end(); The begin member returns an iterator that denotes the first element (or first character), The iterator returned by end is an iterator positioned “one past the end” of the associated container (or string). This iterator denotes a nonexistent element “off the end” of the container. If the container is empty, beginreturns the same iterator as the one returned by end. Iterators support only a few operations, which are listed in next code: #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &quot;Sales_data.h&quot; using std::cout; using std::cin; using std::endl; using std::string; using std::vector; int main() &#123; vector&lt;int&gt; v&#123; 1,2,3,4,5,6,7,8,9 &#125;; //b++: Increments b to refer next element //b--: Decrements b to refer previous element //b != v.end(): Compare two iterator for inequality for (auto b = v.begin(); b != v.end(); b++)&#123; //*b get the reference to the element donated by b *b *= *b; &#125; Sales_data k; k.bookNo = &quot;0-321-71411-3&quot;; vector&lt;Sales_data&gt; sale = &#123;k&#125;; auto sb = sale.begin(), se = sale.end(); //equal to (*sb).bookNo will print 0-321-71411-3 cout &lt;&lt; sb-&gt;bookNo &lt;&lt; endl; return 0; &#125; Like pointer, there ere also has const iterator, when you define a const container(such as vector) or string, the begin and end members are const iterator. You also can use cbigin or cend to get a const iterator when you don not want change element. Except previous operation, they are some operations for special container. Iterators for string and vector support additional operations that can move an iterator multiple elements at a time. They also support all the relational operators. These operations, which are often referred to as iterator arithmetic, are described in the next Table. operation meaning iter + n iter donate to next nth element iter - n iter donate to front nth element iter += n iter donate to next nth element iter -= n iter donate to front nth element &lt;, &gt;, &lt;=, &gt;= compare ArraysAn array is a data structure that is similar to the library vector type, but size of a array is fixed, which mean we can not add new elements. Sometimes they offer better run-time performance for specialized applications. Arrays are a compound type, An array declarator has the form a[d], where a is the name being defined and d is the dimension of the array. the next code show how initial a array: int p = 10; int a[10]; //array of ten ints int* b[10]; //array of ten points to int int d[p]; //error: p is not a constexpr int c[] = &#123; 1,2,3 &#125;; //array of three ints, 1 and 2 and 3 When we define an array, we must specify a type for the array. We cannot use auto to deduce the type from a list of initializers. As with vector, arrays hold objects. Thus, there are no arrays of references. Character arrays have an additional form of initialization. We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. In previous code, we see int* b[10] mean array of ten points to int, so how can we make a pointer point to a array? The next show: int a[10]; //array of ten ints int(*p)[10] = &amp;a; //a pointer point to a int(&amp;r)[10] = a; //a reference refer to a //By default, type modifiers bind right to left. As with the library vector and string types, we can use a range for or the subscript operator to access elements of an array. As usual, the indices start at 0. When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. In C++ pointers and arrays are closely intertwined. In particular, as we’ll see, when we use an array, the compiler ordinarily converts the array to a pointer. #include &lt;iostream&gt; int main() &#123; int f = 10; int a[10]; //array of ten ints for (auto &amp;i : a) &#123; i = f--; &#125; //p is a pointer point to the first element of a auto p = a; //will print 10 std::cout &lt;&lt; *p &lt;&lt; std::endl; return 0; &#125; Array is not a class, so it is not has member donated to begin and end, c++ provide a way to get pointer to fist element and last element. We will use this function in next code. Many C++ programs predate the standard library and do not use the string and vector types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style character strings. The C++ library offers facilities to make the interface easier to manage. #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using std::string; using std::vector; using std::begin; using std::end; int main() &#123; char str[] = &quot;Hello&quot;; string s(str); //c string to std string const char* cs = s.c_str(); // std string to c string, must need const int int_arr[] = &#123; 0, 1, 2, 3, 4, 5 &#125;; // ivec has six elements; each is a copy of the corresponding element in int_arr vector&lt;int&gt; ivec(begin(int_arr), end(int_arr)); return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"(ch1) Getting Started C++","slug":"c++ c1","date":"2021-12-18T13:52:45.000Z","updated":"2023-04-21T08:44:49.694Z","comments":true,"path":"2021/12/18/c++ c1/","link":"","permalink":"https://noahbishop.github.io/2021/12/18/c++%20c1/","excerpt":"","text":"Getting StartedThis chapter introduces most of the basic elements of C++: types, variables,expressions, statements, and functions. I write this post in 2021, today there are many powerful tools can help you write program more efficiently and quickly, I recommend you use vs2019 and create a “Linux project” and running in a virtual machine. you can simply create a virtual machine by VMware. this post is based on c plus plus primer. write a simple c++ programEvery c++ program contains one or more functions, one of which must be named main. The operating system runs a C++ program by calling main, this is a simple c++ program. #include&lt;cstdio&gt; int main() &#123; printf(&quot;hello world!\\n&quot;); return 0; &#125; A function definition has four elements: a return type, a function name, a (possibly empty) parameter list enclosed in parentheses, and a function body. In previous example, the int is return type, main is function name, and don’t have parameter. The function body is a block of statements starting with an open curly brace and ending with a close curly. Note the semicolon at the end of statement, it can lead to compiler error messages when forgotten. Input and outputThe c++ don’t define any statement to do input and output, but c++ include a extensive standard library that provide input and output. In previous case, we print the string “hello world” by use the “printf” function that define in cstdio standard library. Actually, you are recommend use the iostream standard library, the cstdio is from the stdio.h in c language. Fundamental to iostream are istream and ostream, which represent input and output streams. The library defines four IO objects. name in where referred cin istream standard input cout ostream standard output cerr ostream standard error clog ostream general information about the execution of the program This is a sample case, read two numbers form standard input and print the sum by standard output. #include &lt;iostream&gt; int main() &#123; int num1, num2; std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl; std::cin &gt;&gt; num1 &gt;&gt; num2; std::cout &lt;&lt; &quot;the sum is:&quot; &lt;&lt; num1 + num2 &lt;&lt; std::endl; return 0; &#125; //running //Enter two numbers: //10 20 //the sum is:30 The first line in the previous case is #include &lt;iostream&gt; tell the compiler that wo want use the iostream library, we called it header in c++ program. And we notice that the program use the std::cin and std::cout rather than cin and cout, the profix std:: mean the cin and cout are defined in the namespace called std. The namespace allow us to use function that has same name in a program. commentsComments help human reading program, the often to summarize a algorithm and explain what the variable’s mean, the compiler ignore the comments, so they need be identified by special way. //this is a comment /* you can also write conmment is this way */ /*Comment Pairs Do Not Nest /*Comment Pairs Do Not Nest, the end of a comment is */ compler think this line is a statement, because the comments is end*/ Flow of ControlStatement normally execute sequentially, the first statement at main block execute first, follow by second, the most important control ways in program are while loop, for loop and if branch. the following program add all even numbers between 0 to 20. #include &lt;iostream&gt; int main() &#123; /* * this is a simple program that * add all even numbers between 0 to 20 */ int n = 0, sum = 0; //while loop end when n greater than 20 while (n &lt;= 20) &#123; //if n is a even number if (n % 2 == 0) &#123; sum += n; &#125; n++; &#125; std::cout &lt;&lt; &quot;the sum of even numbers between 0 to 20 is &quot; &lt;&lt; sum &lt;&lt; std::endl; sum = 0; //for loop end when i greater than 20 for (int i = 0; i &lt;= 20; i++) &#123; //if i is a even number if (i % 2 == 0) &#123; sum += i; &#125; &#125; std::cout &lt;&lt; &quot;the sum of even numbers between 0 to 20 is &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; &#125; Introducing Classesone of the most difference between c language and c++ language is the c++ has classes. In c++, we define our data structure by define a classes, a class defines a type along with many operations that are related to this type. We will discuss more details in the next post.","categories":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++ basic","slug":"C-C-basic","permalink":"https://noahbishop.github.io/tags/C-C-basic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://noahbishop.github.io/categories/%E6%8A%80%E6%9C%AF/"}]}]}